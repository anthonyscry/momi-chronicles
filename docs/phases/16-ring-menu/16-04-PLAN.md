---
phase: 16-ring-menu
plan: 04
type: execute
wave: 3
depends_on: ["16-01", "16-02"]
files_modified:
  - systems/party/companion_data.gd
  - systems/party/party_manager.gd
  - systems/party/companion_ai.gd
  - characters/companions/companion_base.gd
  - characters/companions/companion_base.tscn
  - characters/companions/momi_companion.gd
  - characters/companions/cinnamon_companion.gd
  - characters/companions/philo_companion.gd
  - ui/ring_menu/ring_menu.gd
  - ui/hud/companion_hud.gd
  - ui/hud/companion_hud.tscn
  - ui/hud/game_hud.tscn
  - autoloads/game_manager.gd
  - autoloads/events.gd
  - project.godot
autonomous: true

must_haves:
  truths:
    - "All 3 bulldogs fight together simultaneously"
    - "Q key cycles active companion control (Momi -> Cinnamon -> Philo)"
    - "Non-controlled companions have AI behavior"
    - "Each companion has visible health bar and unique meter"
    - "Companions can be knocked out and need healing"
    - "Momi's Zoomies meter builds from combat, drains when activated"
    - "Cinnamon's Overheat meter builds from blocking, forces cooldown when maxed"
    - "Philo's Motivation meter starts high, drains over time, restores when Momi gets hit"
  artifacts:
    - path: "systems/party/party_manager.gd"
      provides: "Party management and companion control switching"
      exports: ["PartyManager"]
    - path: "characters/companions/companion_base.gd"
      provides: "Base companion with AI and meter system"
    - path: "ui/hud/companion_hud.gd"
      provides: "Health bars and meters for all companions"
  key_links:
    - from: "party_manager.gd"
      to: "ring_menu.gd"
      via: "Companions ring integration"
      pattern: "get_companions_for_ring"
    - from: "companion_base.gd"
      to: "events.gd"
      via: "companion signals"
      pattern: "companion_knocked_out|companion_meter_changed"
    - from: "game_manager.gd"
      to: "party_manager.gd"
      via: "party system ownership"
      pattern: "party_manager"
---

<objective>
Create the full party system with 3 AI-controlled bulldog companions fighting together.

Purpose: Enable strategic party combat with unique companion mechanics
Output: Working party system with Q-cycling, AI companions, and unique meters
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-ring-menu/16-CONTEXT.md
@.planning/phases/16-ring-menu/16-01-SUMMARY.md
@.planning/phases/16-ring-menu/16-02-SUMMARY.md
@characters/player/player.gd
@characters/enemies/enemy_base.gd
@ui/ring_menu/ring_menu.gd
@autoloads/game_manager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Companion Data and Party Manager</name>
  <files>
    systems/party/companion_data.gd
    systems/party/party_manager.gd
    autoloads/game_manager.gd
    autoloads/events.gd
    project.godot
  </files>
  <action>
Create companion definitions and party management:

```gdscript
# systems/party/companion_data.gd
extends Node
class_name CompanionData

## Companion roles
enum Role { DPS, TANK, SUPPORT }

## AI behavior presets (configurable from Options ring)
enum AIPreset { AGGRESSIVE, BALANCED, DEFENSIVE }

## Companion definitions - The Bulldog Squad!
const COMPANIONS: Dictionary = {
    "momi": {
        "id": "momi",
        "name": "Momi",
        "breed": "French Bulldog",
        "role": Role.DPS,
        "desc": "The brave leader. Fast attacks and Zoomies mode!",
        "color": Color(0.9, 0.7, 0.5),  # Fawn
        "base_stats": {
            "max_health": 100,
            "attack_damage": 25,
            "move_speed": 80,
            "attack_speed": 1.0,
        },
        "meter": {
            "name": "Zoomies",
            "desc": "Builds from combat. Activate for speed boost!",
            "color": Color(1.0, 0.8, 0.2),  # Yellow/Gold
            "max_value": 100.0,
            "start_value": 0.0,  # Starts empty, builds up
            "build_rate": 5.0,   # Per hit dealt
            "drain_rate": 15.0,  # Per second when active
        },
    },
    "cinnamon": {
        "id": "cinnamon",
        "name": "Cinnamon",
        "breed": "English Bulldog",
        "role": Role.TANK,
        "desc": "The stalwart defender. Blocks hits but watch the heat!",
        "color": Color(0.8, 0.5, 0.3),  # Brown/Cinnamon
        "base_stats": {
            "max_health": 150,
            "attack_damage": 18,
            "move_speed": 60,
            "attack_speed": 0.8,
        },
        "meter": {
            "name": "Overheat",
            "desc": "Builds from blocking. Maxed = forced cooldown!",
            "color": Color(1.0, 0.3, 0.1),  # Red/Orange
            "max_value": 100.0,
            "start_value": 0.0,  # Starts cool
            "build_rate": 10.0,  # Per blocked hit
            "drain_rate": 8.0,   # Per second when not blocking
        },
    },
    "philo": {
        "id": "philo",
        "name": "Philo",
        "breed": "Boston Terrier",
        "role": Role.SUPPORT,
        "desc": "The loyal supporter. Gets motivated when the team needs help!",
        "color": Color(0.2, 0.2, 0.25),  # Black/White
        "base_stats": {
            "max_health": 80,
            "attack_damage": 15,
            "move_speed": 90,
            "attack_speed": 1.2,
        },
        "meter": {
            "name": "Motivation",
            "desc": "Starts high, drains over time. Restores when Momi gets hit!",
            "color": Color(0.3, 0.8, 1.0),  # Cyan/Blue
            "max_value": 100.0,
            "start_value": 100.0,  # STARTS HIGH (unique!)
            "build_rate": 25.0,    # Per Momi damage taken
            "drain_rate": 3.0,     # Per second passive drain
        },
    },
}

## Get companion data
static func get_companion(companion_id: String) -> Dictionary:
    if COMPANIONS.has(companion_id):
        return COMPANIONS[companion_id].duplicate(true)
    return {}

## Get all companions
static func get_all_companions() -> Array:
    var result = []
    for id in COMPANIONS:
        result.append(COMPANIONS[id].duplicate(true))
    return result
```

```gdscript
# systems/party/party_manager.gd
extends Node
class_name PartyManager

signal active_companion_changed(companion_id: String)
signal companion_knocked_out(companion_id: String)
signal companion_revived(companion_id: String)
signal companion_meter_changed(companion_id: String, current: float, max_val: float)

## Party order for Q cycling
const PARTY_ORDER: Array[String] = ["momi", "cinnamon", "philo"]

## Currently controlled companion
var active_companion_id: String = "momi"

## Companion instances (populated when zone loads)
var companions: Dictionary = {}  # {id: CompanionBase node}

## Knocked out companions
var knocked_out: Dictionary = {}  # {id: true}

## AI preset per companion
var ai_presets: Dictionary = {
    "momi": CompanionData.AIPreset.AGGRESSIVE,
    "cinnamon": CompanionData.AIPreset.DEFENSIVE,
    "philo": CompanionData.AIPreset.BALANCED,
}

func _ready() -> void:
    # Connect to player damage for Philo's mechanic
    Events.player_damaged.connect(_on_player_damaged)

func _unhandled_input(event: InputEvent) -> void:
    # Q to cycle companion control
    if event.is_action_pressed("cycle_companion"):
        cycle_active_companion()
        get_viewport().set_input_as_handled()

## Cycle to next companion (Q key)
func cycle_active_companion() -> void:
    var current_index = PARTY_ORDER.find(active_companion_id)
    
    # Find next non-knocked-out companion
    for i in range(1, PARTY_ORDER.size() + 1):
        var next_index = (current_index + i) % PARTY_ORDER.size()
        var next_id = PARTY_ORDER[next_index]
        
        if not knocked_out.has(next_id):
            _switch_to_companion(next_id)
            return
    
    # All knocked out - can't switch
    AudioManager.play_sfx("menu_error")

func _switch_to_companion(companion_id: String) -> void:
    if active_companion_id == companion_id:
        return
    
    var old_active = active_companion_id
    active_companion_id = companion_id
    
    # Update control modes
    if companions.has(old_active):
        companions[old_active].set_player_controlled(false)
    if companions.has(companion_id):
        companions[companion_id].set_player_controlled(true)
    
    active_companion_changed.emit(companion_id)
    Events.active_companion_changed.emit(companion_id)
    AudioManager.play_sfx("menu_switch")

## Register companion instance
func register_companion(companion_id: String, companion_node: Node) -> void:
    companions[companion_id] = companion_node
    companion_node.knocked_out.connect(_on_companion_knocked_out.bind(companion_id))
    companion_node.meter_changed.connect(_on_meter_changed.bind(companion_id))
    
    # Set initial control mode
    companion_node.set_player_controlled(companion_id == active_companion_id)

## Knock out a companion
func _on_companion_knocked_out(companion_id: String) -> void:
    knocked_out[companion_id] = true
    companion_knocked_out.emit(companion_id)
    Events.companion_knocked_out.emit(companion_id)
    
    # If active companion knocked out, switch to another
    if companion_id == active_companion_id:
        cycle_active_companion()

## Revive a companion (via item or safe zone)
func revive_companion(companion_id: String, health_percent: float = 0.5) -> void:
    if not knocked_out.has(companion_id):
        return
    
    knocked_out.erase(companion_id)
    
    if companions.has(companion_id):
        companions[companion_id].revive(health_percent)
    
    companion_revived.emit(companion_id)
    Events.companion_revived.emit(companion_id)

## Handle Philo's motivation mechanic - restores when Momi gets hit
func _on_player_damaged(amount: int) -> void:
    # Only trigger if Momi is active (player IS Momi)
    if active_companion_id == "momi" and companions.has("philo"):
        companions["philo"].on_ally_damaged(amount)

## Meter change forwarding
func _on_meter_changed(current: float, max_val: float, companion_id: String) -> void:
    companion_meter_changed.emit(companion_id, current, max_val)
    Events.companion_meter_changed.emit(companion_id, current, max_val)

## Get companion for ring menu
func get_companions_for_ring() -> Array[Dictionary]:
    var result: Array[Dictionary] = []
    
    for companion_id in PARTY_ORDER:
        var data = CompanionData.get_companion(companion_id)
        data["is_active"] = (companion_id == active_companion_id)
        data["is_knocked_out"] = knocked_out.has(companion_id)
        
        # Get current health/meter if companion exists
        if companions.has(companion_id):
            var comp = companions[companion_id]
            data["current_health"] = comp.get_current_health()
            data["max_health"] = comp.get_max_health()
            data["current_meter"] = comp.get_meter_value()
            data["max_meter"] = comp.get_meter_max()
        
        result.append(data)
    
    return result

## Set AI preset for companion
func set_ai_preset(companion_id: String, preset: int) -> void:
    ai_presets[companion_id] = preset
    if companions.has(companion_id):
        companions[companion_id].set_ai_preset(preset)

## Get active companion node
func get_active_companion() -> Node:
    if companions.has(active_companion_id):
        return companions[active_companion_id]
    return null

## Check if companion is knocked out
func is_knocked_out(companion_id: String) -> bool:
    return knocked_out.has(companion_id)
```

Add to GameManager:
```gdscript
var party_manager: PartyManager = null

func _ready() -> void:
    # ... existing code ...
    party_manager = PartyManager.new()
    add_child(party_manager)
```

Add signals to Events:
```gdscript
# Companion/Party Signals
signal active_companion_changed(companion_id: String)
signal companion_knocked_out(companion_id: String)
signal companion_revived(companion_id: String)
signal companion_meter_changed(companion_id: String, current: float, max_val: float)
```

Add input action to project.godot:
```
cycle_companion = Q key
```
  </action>
  <verify>
PartyManager exists in GameManager
Q key cycles through companions
Knocked out companions are skipped in cycle
Signals emit correctly
  </verify>
  <done>Party manager handles companion cycling and state tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create Companion Base and AI</name>
  <files>
    systems/party/companion_ai.gd
    characters/companions/companion_base.gd
    characters/companions/companion_base.tscn
    characters/companions/momi_companion.gd
    characters/companions/cinnamon_companion.gd
    characters/companions/philo_companion.gd
  </files>
  <action>
Create companion AI and base class:

```gdscript
# systems/party/companion_ai.gd
extends Node
class_name CompanionAI

## AI behavior presets
var preset: int = CompanionData.AIPreset.BALANCED

## Distance settings per preset
const PRESET_DISTANCES: Dictionary = {
    CompanionData.AIPreset.AGGRESSIVE: {"follow": 60, "attack": 120},
    CompanionData.AIPreset.BALANCED: {"follow": 80, "attack": 100},
    CompanionData.AIPreset.DEFENSIVE: {"follow": 40, "attack": 80},
}

## Reference to owner
var owner_node: CharacterBody2D = null

## Target tracking
var current_target: Node2D = null
var target_update_timer: float = 0.0
const TARGET_UPDATE_INTERVAL: float = 0.5

## Attack cooldown
var attack_cooldown: float = 0.0
var attack_rate: float = 1.5  # Seconds between attacks

## Reference to active (player-controlled) companion for following
var follow_target: Node2D = null

func setup(owner: CharacterBody2D, ai_preset: int) -> void:
    owner_node = owner
    preset = ai_preset

func _process(delta: float) -> void:
    if not owner_node or owner_node.is_player_controlled:
        return
    
    attack_cooldown = max(0, attack_cooldown - delta)
    target_update_timer += delta
    
    if target_update_timer >= TARGET_UPDATE_INTERVAL:
        target_update_timer = 0.0
        _update_target()

func get_ai_move_direction() -> Vector2:
    if not owner_node:
        return Vector2.ZERO
    
    var distances = PRESET_DISTANCES[preset]
    
    # Priority 1: Attack nearby enemy
    if current_target and is_instance_valid(current_target):
        var dist = owner_node.global_position.distance_to(current_target.global_position)
        if dist <= distances.attack:
            # Move toward enemy
            return (current_target.global_position - owner_node.global_position).normalized()
    
    # Priority 2: Follow active companion
    if follow_target and is_instance_valid(follow_target):
        var dist = owner_node.global_position.distance_to(follow_target.global_position)
        if dist > distances.follow:
            return (follow_target.global_position - owner_node.global_position).normalized()
    
    return Vector2.ZERO

func should_attack() -> bool:
    if attack_cooldown > 0:
        return false
    
    if current_target and is_instance_valid(current_target):
        var dist = owner_node.global_position.distance_to(current_target.global_position)
        var attack_range = 30.0  # Close range for melee
        
        if dist <= attack_range:
            attack_cooldown = attack_rate / owner_node.attack_speed_multiplier
            return true
    
    return false

func should_block() -> bool:
    # Tank preset blocks more
    if preset != CompanionData.AIPreset.DEFENSIVE:
        return false
    
    # Check if enemy is attacking nearby
    if current_target and is_instance_valid(current_target):
        var dist = owner_node.global_position.distance_to(current_target.global_position)
        if dist < 50.0 and current_target.has_method("is_attacking") and current_target.is_attacking():
            return true
    
    return false

func _update_target() -> void:
    # Find closest enemy
    var enemies = owner_node.get_tree().get_nodes_in_group("enemies")
    var closest: Node2D = null
    var closest_dist: float = INF
    
    for enemy in enemies:
        if not is_instance_valid(enemy) or enemy.has_method("is_dead") and enemy.is_dead():
            continue
        
        var dist = owner_node.global_position.distance_to(enemy.global_position)
        if dist < closest_dist:
            closest_dist = dist
            closest = enemy
    
    current_target = closest

func set_follow_target(target: Node2D) -> void:
    follow_target = target
```

```gdscript
# characters/companions/companion_base.gd
extends CharacterBody2D
class_name CompanionBase

signal knocked_out
signal revived
signal meter_changed(current: float, max_val: float)

## Companion ID (momi, cinnamon, philo)
@export var companion_id: String = ""

## Whether player is controlling this companion
var is_player_controlled: bool = false

## Stats
var max_health: int = 100
var current_health: int = 100
var attack_damage: int = 20
var move_speed: float = 80.0
var attack_speed_multiplier: float = 1.0

## Meter system
var meter_value: float = 0.0
var meter_max: float = 100.0
var meter_name: String = "Meter"
var meter_build_rate: float = 5.0
var meter_drain_rate: float = 10.0
var meter_active: bool = false  # For Momi's Zoomies activation

## Knocked out state
var is_knocked_out: bool = false

## Components
@onready var sprite: Polygon2D = $Sprite2D
@onready var ai: CompanionAI = $CompanionAI
@onready var hitbox: Hitbox = $Hitbox
@onready var hurtbox: Hurtbox = $Hurtbox

func _ready() -> void:
    add_to_group("companions")
    add_to_group("player_allies")
    
    # Load companion data
    _load_companion_data()
    
    # Connect signals
    if hurtbox:
        hurtbox.hurt.connect(_on_hurt)
    
    # Register with party manager
    if GameManager.party_manager:
        GameManager.party_manager.register_companion(companion_id, self)
    
    # Setup AI
    if ai:
        ai.setup(self, GameManager.party_manager.ai_presets.get(companion_id, 1))

func _load_companion_data() -> void:
    var data = CompanionData.get_companion(companion_id)
    if data.is_empty():
        return
    
    # Base stats
    var stats = data.base_stats
    max_health = stats.max_health
    current_health = max_health
    attack_damage = stats.attack_damage
    move_speed = stats.move_speed
    attack_speed_multiplier = stats.attack_speed
    
    # Meter
    var meter = data.meter
    meter_name = meter.name
    meter_max = meter.max_value
    meter_value = meter.start_value  # Important: Philo starts at 100!
    meter_build_rate = meter.build_rate
    meter_drain_rate = meter.drain_rate
    
    # Visuals
    if sprite:
        sprite.color = data.color
    
    if hitbox:
        hitbox.damage = attack_damage

func _physics_process(delta: float) -> void:
    if is_knocked_out:
        return
    
    # Process meter
    _update_meter(delta)
    
    # Movement
    var direction: Vector2
    if is_player_controlled:
        direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    else:
        direction = ai.get_ai_move_direction() if ai else Vector2.ZERO
    
    var speed = move_speed * _get_speed_multiplier()
    velocity = direction * speed
    move_and_slide()
    
    # Attack logic
    if _should_attack():
        _perform_attack()

func _should_attack() -> bool:
    if is_player_controlled:
        return Input.is_action_just_pressed("attack")
    else:
        return ai.should_attack() if ai else false

func _perform_attack() -> void:
    # Enable hitbox briefly
    if hitbox:
        hitbox.enable()
        await get_tree().create_timer(0.15).timeout
        hitbox.disable()
    
    # Build meter on attack (Momi's Zoomies)
    _on_attack_performed()

## Override in subclasses for unique meter behavior
func _update_meter(delta: float) -> void:
    pass  # Implemented in subclasses

func _on_attack_performed() -> void:
    pass  # Override for meter building

func _get_speed_multiplier() -> float:
    return 1.0  # Override for Zoomies

func _on_hurt(attacking_hitbox: Hitbox) -> void:
    var damage = attacking_hitbox.damage
    take_damage(damage)

func take_damage(amount: int) -> void:
    current_health -= amount
    current_health = max(0, current_health)
    
    # Flash effect
    _flash_hurt()
    
    if current_health <= 0:
        _knock_out()

func _flash_hurt() -> void:
    if sprite:
        sprite.modulate = Color.RED
        await get_tree().create_timer(0.1).timeout
        sprite.modulate = Color.WHITE

func _knock_out() -> void:
    is_knocked_out = true
    visible = false  # Hide knocked out companion
    knocked_out.emit()

func revive(health_percent: float = 0.5) -> void:
    is_knocked_out = false
    current_health = int(max_health * health_percent)
    visible = true
    revived.emit()

func heal(amount: int) -> void:
    current_health = min(current_health + amount, max_health)

func set_player_controlled(controlled: bool) -> void:
    is_player_controlled = controlled
    
    # Update AI follow target
    if ai and not controlled:
        var active = GameManager.party_manager.get_active_companion()
        ai.set_follow_target(active)

func set_ai_preset(preset: int) -> void:
    if ai:
        ai.preset = preset

## Getters for HUD
func get_current_health() -> int:
    return current_health

func get_max_health() -> int:
    return max_health

func get_meter_value() -> float:
    return meter_value

func get_meter_max() -> float:
    return meter_max

## Called when ally takes damage (for Philo)
func on_ally_damaged(amount: int) -> void:
    pass  # Override in Philo
```

Now create specific companion classes:

```gdscript
# characters/companions/momi_companion.gd
extends CompanionBase
class_name MomiCompanion

## Zoomies state
var zoomies_active: bool = false
const ZOOMIES_SPEED_MULT: float = 1.5
const ZOOMIES_ATTACK_MULT: float = 1.3

func _ready() -> void:
    companion_id = "momi"
    super._ready()

func _update_meter(delta: float) -> void:
    if zoomies_active:
        # Drain while active
        meter_value -= meter_drain_rate * delta
        if meter_value <= 0:
            meter_value = 0
            _deactivate_zoomies()
    
    meter_changed.emit(meter_value, meter_max)

func _on_attack_performed() -> void:
    if not zoomies_active:
        # Build meter from combat
        meter_value = min(meter_value + meter_build_rate, meter_max)
        meter_changed.emit(meter_value, meter_max)

func _get_speed_multiplier() -> float:
    return ZOOMIES_SPEED_MULT if zoomies_active else 1.0

func _unhandled_input(event: InputEvent) -> void:
    if not is_player_controlled:
        return
    
    # Special ability key to activate Zoomies
    if event.is_action_pressed("special_attack") and meter_value >= 50:
        if not zoomies_active:
            _activate_zoomies()

func _activate_zoomies() -> void:
    zoomies_active = true
    meter_active = true
    if hitbox:
        hitbox.damage = int(attack_damage * ZOOMIES_ATTACK_MULT)
    AudioManager.play_sfx("power_up")

func _deactivate_zoomies() -> void:
    zoomies_active = false
    meter_active = false
    if hitbox:
        hitbox.damage = attack_damage
```

```gdscript
# characters/companions/cinnamon_companion.gd
extends CompanionBase
class_name CinnamonCompanion

## Overheat state
var is_blocking: bool = false
var is_overheated: bool = false
const OVERHEAT_COOLDOWN: float = 3.0
var overheat_timer: float = 0.0

func _ready() -> void:
    companion_id = "cinnamon"
    super._ready()

func _update_meter(delta: float) -> void:
    if is_overheated:
        # Forced cooldown - drain quickly
        meter_value -= meter_drain_rate * 2.0 * delta
        overheat_timer -= delta
        
        if overheat_timer <= 0 or meter_value <= 0:
            meter_value = 0
            is_overheated = false
    elif is_blocking:
        # Heat builds while blocking (handled in _on_blocked)
        pass
    else:
        # Cool down when not blocking
        meter_value = max(0, meter_value - meter_drain_rate * delta)
    
    meter_changed.emit(meter_value, meter_max)

func _physics_process(delta: float) -> void:
    super._physics_process(delta)
    
    # Block input
    if is_player_controlled and not is_overheated:
        is_blocking = Input.is_action_pressed("block")
    elif not is_player_controlled and ai:
        is_blocking = ai.should_block() and not is_overheated

func _on_hurt(attacking_hitbox: Hitbox) -> void:
    if is_blocking and not is_overheated:
        # Block reduces damage
        var damage = int(attacking_hitbox.damage * 0.5)
        take_damage(damage)
        
        # Build overheat
        meter_value += meter_build_rate
        if meter_value >= meter_max:
            _trigger_overheat()
        
        meter_changed.emit(meter_value, meter_max)
    else:
        super._on_hurt(attacking_hitbox)

func _trigger_overheat() -> void:
    is_overheated = true
    is_blocking = false
    overheat_timer = OVERHEAT_COOLDOWN
    meter_value = meter_max
    
    # Visual feedback
    if sprite:
        sprite.modulate = Color(1.0, 0.5, 0.3)  # Orange tint
    
    AudioManager.play_sfx("guard_break")
    
    # Reset color after cooldown
    await get_tree().create_timer(OVERHEAT_COOLDOWN).timeout
    if sprite:
        sprite.modulate = Color.WHITE
```

```gdscript
# characters/companions/philo_companion.gd
extends CompanionBase
class_name PhiloCompanion

## Motivation affects healing output
const HIGH_MOTIVATION_THRESHOLD: float = 70.0
const MOTIVATION_HEAL_BONUS: float = 1.5

func _ready() -> void:
    companion_id = "philo"
    super._ready()

func _update_meter(delta: float) -> void:
    # Motivation drains over time (unique: starts high!)
    meter_value = max(0, meter_value - meter_drain_rate * delta)
    meter_changed.emit(meter_value, meter_max)
    
    # Visual indicator when motivation is low
    if sprite:
        if meter_value < 30:
            sprite.modulate = Color(0.7, 0.7, 0.8)  # Dim when unmotivated
        else:
            sprite.modulate = Color.WHITE

## Called when Momi (active companion) takes damage
## This is Philo's unique mechanic - gets motivated when team needs help!
func on_ally_damaged(amount: int) -> void:
    # Restore motivation when Momi gets hit
    var motivation_gain = meter_build_rate * (amount / 10.0)
    meter_value = min(meter_value + motivation_gain, meter_max)
    meter_changed.emit(meter_value, meter_max)
    
    # Visual feedback
    if sprite:
        sprite.modulate = Color(0.5, 1.0, 1.0)  # Cyan flash
        await get_tree().create_timer(0.2).timeout
        sprite.modulate = Color.WHITE

## Philo's attacks can heal allies when motivated
func _on_attack_performed() -> void:
    if meter_value >= HIGH_MOTIVATION_THRESHOLD:
        # High motivation = bonus healing to nearby allies
        _heal_nearby_allies()

func _heal_nearby_allies() -> void:
    var allies = get_tree().get_nodes_in_group("player_allies")
    for ally in allies:
        if ally == self:
            continue
        if ally.global_position.distance_to(global_position) < 80:
            if ally.has_method("heal"):
                ally.heal(3)  # Small heal per attack
```

Create companion_base.tscn structure (similar to player):
```
CompanionBase (CharacterBody2D)
├── Sprite2D (Polygon2D, 16x16 colored square)
├── CollisionShape2D (CircleShape2D, radius 6)
├── Hitbox (Area2D with CollisionShape2D)
├── Hurtbox (Area2D with CollisionShape2D)
└── CompanionAI (Node)
```
  </action>
  <verify>
Companion scenes load without errors
Momi's Zoomies meter builds from attacks, drains when active
Cinnamon's Overheat builds from blocking, forces cooldown
Philo's Motivation starts high, restores when Momi hit
AI companions follow and attack
  </verify>
  <done>Three unique companions with distinct meter mechanics</done>
</task>

<task type="auto">
  <name>Task 3: Create Companion HUD and Ring Menu Integration</name>
  <files>
    ui/hud/companion_hud.gd
    ui/hud/companion_hud.tscn
    ui/hud/game_hud.tscn
    ui/ring_menu/ring_menu.gd
  </files>
  <action>
Create companion HUD showing health bars and meters:

```gdscript
# ui/hud/companion_hud.gd
extends Control
class_name CompanionHUD

## Companion display panels
@onready var momi_panel: Control = $MomiPanel
@onready var cinnamon_panel: Control = $CinnamonPanel
@onready var philo_panel: Control = $PhiloPanel

## Per-companion elements
var panels: Dictionary = {}

func _ready() -> void:
    # Set up panel references
    panels = {
        "momi": {
            "panel": momi_panel,
            "health_bar": momi_panel.get_node("HealthBar") if momi_panel else null,
            "meter_bar": momi_panel.get_node("MeterBar") if momi_panel else null,
            "name_label": momi_panel.get_node("NameLabel") if momi_panel else null,
            "ko_overlay": momi_panel.get_node("KOOverlay") if momi_panel else null,
        },
        "cinnamon": {
            "panel": cinnamon_panel,
            "health_bar": cinnamon_panel.get_node("HealthBar") if cinnamon_panel else null,
            "meter_bar": cinnamon_panel.get_node("MeterBar") if cinnamon_panel else null,
            "name_label": cinnamon_panel.get_node("NameLabel") if cinnamon_panel else null,
            "ko_overlay": cinnamon_panel.get_node("KOOverlay") if cinnamon_panel else null,
        },
        "philo": {
            "panel": philo_panel,
            "health_bar": philo_panel.get_node("HealthBar") if philo_panel else null,
            "meter_bar": philo_panel.get_node("MeterBar") if philo_panel else null,
            "name_label": philo_panel.get_node("NameLabel") if philo_panel else null,
            "ko_overlay": philo_panel.get_node("KOOverlay") if philo_panel else null,
        },
    }
    
    # Connect to events
    Events.active_companion_changed.connect(_on_active_changed)
    Events.companion_knocked_out.connect(_on_knocked_out)
    Events.companion_revived.connect(_on_revived)
    Events.companion_meter_changed.connect(_on_meter_changed)
    
    # Initialize display
    _initialize_panels()

func _initialize_panels() -> void:
    for companion_id in panels:
        var data = CompanionData.get_companion(companion_id)
        var p = panels[companion_id]
        
        # Set name
        if p.name_label:
            p.name_label.text = data.name
        
        # Set meter color based on companion
        if p.meter_bar:
            p.meter_bar.modulate = data.meter.color
        
        # Hide KO overlay initially
        if p.ko_overlay:
            p.ko_overlay.visible = false
    
    # Highlight active companion
    _highlight_active(GameManager.party_manager.active_companion_id if GameManager.party_manager else "momi")

func _highlight_active(companion_id: String) -> void:
    for id in panels:
        var p = panels[id]
        if p.panel:
            # Active companion has brighter border/background
            if id == companion_id:
                p.panel.modulate = Color.WHITE
            else:
                p.panel.modulate = Color(0.7, 0.7, 0.7)

func _on_active_changed(companion_id: String) -> void:
    _highlight_active(companion_id)

func _on_knocked_out(companion_id: String) -> void:
    var p = panels.get(companion_id)
    if p and p.ko_overlay:
        p.ko_overlay.visible = true
    if p and p.panel:
        p.panel.modulate = Color(0.4, 0.4, 0.4)

func _on_revived(companion_id: String) -> void:
    var p = panels.get(companion_id)
    if p and p.ko_overlay:
        p.ko_overlay.visible = false
    _highlight_active(GameManager.party_manager.active_companion_id if GameManager.party_manager else "momi")

func _on_meter_changed(companion_id: String, current: float, max_val: float) -> void:
    var p = panels.get(companion_id)
    if p and p.meter_bar:
        p.meter_bar.value = (current / max_val) * 100.0

func update_health(companion_id: String, current: int, max_hp: int) -> void:
    var p = panels.get(companion_id)
    if p and p.health_bar:
        p.health_bar.value = (float(current) / max_hp) * 100.0
```

Create companion_hud.tscn:
```
CompanionHUD (Control, anchored top-left, below main health bar)
├── MomiPanel (Control, 60x30)
│   ├── Background (ColorRect, dark semi-transparent)
│   ├── NameLabel (Label, "Momi", small font)
│   ├── HealthBar (ProgressBar, red, 50x6)
│   ├── MeterBar (ProgressBar, yellow, 50x4)
│   └── KOOverlay (ColorRect, red X or "KO" label, initially hidden)
├── CinnamonPanel (Control, 60x30, below Momi)
│   └── (same structure)
└── PhiloPanel (Control, 60x30, below Cinnamon)
    └── (same structure)
```

Add to game_hud.tscn - instance CompanionHUD below the existing health bar.

Update Ring Menu for companions:

```gdscript
# In ring_menu.gd - Update _refresh_ring
func _refresh_ring() -> void:
    match current_ring:
        RingType.ITEMS:
            rings[RingType.ITEMS] = _get_inventory_items()
        RingType.EQUIPMENT:
            rings[RingType.EQUIPMENT] = _get_equipment_items()
        RingType.COMPANIONS:
            rings[RingType.COMPANIONS] = _get_companions()
    
    # ... rest of existing code ...

func _get_companions() -> Array:
    if not GameManager.party_manager:
        return []
    return GameManager.party_manager.get_companions_for_ring()

# Update _switch_companion to handle companion ring selection
func _switch_companion(item: Dictionary) -> void:
    var companion_id = item.get("id", "")
    if companion_id.is_empty():
        return
    
    # Check if knocked out
    if item.get("is_knocked_out", false):
        # Show option to use revive item
        AudioManager.play_sfx("menu_error")
        return
    
    # Switch active control to this companion (if not already active)
    if not item.get("is_active", false):
        GameManager.party_manager._switch_to_companion(companion_id)
    
    # Close menu after switching
    close_menu()
```

Update RingItem to show companion state:
```gdscript
# In ring_item.gd setup() - add companion handling
func setup(data: Dictionary) -> void:
    item_data = data
    
    # ... existing icon/label setup ...
    
    # Companion-specific display
    if data.get("type") == "companion" or data.has("breed"):
        # Show role and status
        var status = ""
        if data.get("is_active", false):
            status = "[ACTIVE]"
        elif data.get("is_knocked_out", false):
            status = "[KO]"
        
        if label:
            label.text = "%s\n%s" % [data.get("name", "???"), status]
        
        # Color based on role
        var role_color = Color.WHITE
        match data.get("role", 0):
            CompanionData.Role.DPS:
                role_color = Color(1.0, 0.5, 0.5)  # Red tint
            CompanionData.Role.TANK:
                role_color = Color(0.5, 0.5, 1.0)  # Blue tint
            CompanionData.Role.SUPPORT:
                role_color = Color(0.5, 1.0, 0.5)  # Green tint
        
        if glow:
            glow.color = role_color
```
  </action>
  <verify>
Companion HUD shows all 3 companions
Health and meter bars update correctly
Active companion highlighted
KO state shows overlay
Ring menu Companions tab shows all 3
Can select companion to switch control
  </verify>
  <done>Companion HUD and ring menu integration complete</done>
</task>

</tasks>

<verification>
1. Start game - see 3 companions on screen (Momi, Cinnamon, Philo)
2. Companion HUD shows all 3 with health bars and meters
3. Momi is initially active (highlighted in HUD)
4. Press Q - switch to Cinnamon (HUD updates)
5. Press Q again - switch to Philo
6. Open ring menu, go to Companions ring
7. See all 3 companions with status
8. Select Momi to switch back
9. Attack enemies - Momi's Zoomies meter builds
10. Block with Cinnamon - Overheat meter builds
11. Let Momi take damage - Philo's Motivation restores
12. Let a companion HP reach 0 - they get knocked out
13. Knocked out companion skipped in Q cycle
14. Open ring menu - KO companion shows [KO] status
15. Use healing item on KO companion - they revive
</verification>

<success_criteria>
- All 3 bulldogs fight together simultaneously
- Q key cycles control between non-KO companions
- Non-controlled companions have working AI
- AI follows active companion, attacks nearby enemies
- Companion HUD shows health + unique meter for each
- Momi: Zoomies builds from combat, activatable for speed
- Cinnamon: Overheat builds from blocking, forces cooldown
- Philo: Motivation starts high, drains passively, restores when Momi hit
- Companions can be knocked out (HP = 0)
- KO companions need healing to revive
- Ring menu Companions tab shows all with status
- Visual indicators for active/KO state
</success_criteria>

<output>
After completion, create `.planning/phases/16-ring-menu/16-04-SUMMARY.md`
</output>
