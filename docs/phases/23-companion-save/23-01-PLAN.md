---
phase: 23-companion-save
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - systems/party/party_manager.gd
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Companion health values persist across save/load cycles"
    - "Companion meter values persist across save/load cycles"
    - "Deferred application works — health/meters applied after companions register"
    - "Missing health/meter data in old saves doesn't crash (graceful fallback)"
  artifacts:
    - path: "systems/party/party_manager.gd"
      provides: "Deferred companion health/meter restoration on load"
      contains: "_pending_health"
  key_links:
    - from: "systems/party/party_manager.gd load_save_data()"
      to: "systems/party/party_manager.gd register_companion()"
      via: "_pending_health and _pending_meters dicts stored on load, applied on register"
      pattern: "_pending_health"
---

<objective>
Fix PartyManager.load_save_data() to restore companion health and meter values that get_save_data() already saves but load_save_data() silently ignores.

Purpose: Close the last integration gap from the v1.3.1 audit — companions currently always spawn at full HP after load, losing any damage/meter state.

Output: Updated party_manager.gd with deferred health/meter restoration matching SaveManager's _pending_level/_pending_exp pattern
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/v1.3.1-MILESTONE-AUDIT.md
@systems/party/party_manager.gd
@autoloads/save_manager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deferred health/meter restoration to PartyManager</name>
  <files>systems/party/party_manager.gd</files>
  <action>
  The problem: `load_save_data()` (line 179) restores active_companion_id, knocked_out, and ai_presets — but ignores `health` and `meters` keys from the save data. Companion nodes don't exist yet at load time (zone hasn't loaded), so we need deferred application.

  **Pattern to follow:** SaveManager stores `_pending_level` and `_pending_exp`, then applies them in `_on_zone_entered_after_load()` after player spawns. We'll do the same — store pending health/meters, apply when companions register via `register_companion()`.

  **Changes to party_manager.gd:**

  1. **Add pending state variables** (after line 26, in the state section with other vars):
     ```gdscript
     ## Pending health/meters from save data (applied when companions register)
     var _pending_health: Dictionary = {}  # {companion_id: health_value}
     var _pending_meters: Dictionary = {}  # {companion_id: meter_value}
     ```

  2. **Update load_save_data()** (after line 190, before end of function):
     Add these lines to store the pending health/meters from the save data:
     ```gdscript
     # Store pending health/meters for deferred application
     # (companion nodes don't exist yet — applied in register_companion)
     _pending_health = data.get("health", {})
     _pending_meters = data.get("meters", {})
     ```

  3. **Update register_companion()** (after line 78, before end of function):
     After setting initial control mode, apply pending health/meters if available:
     ```gdscript
     # Apply pending health/meter from save data (deferred restoration)
     if _pending_health.has(companion_id):
         companion_node.set_health(_pending_health[companion_id])
         _pending_health.erase(companion_id)
     if _pending_meters.has(companion_id):
         companion_node.set_meter_value(_pending_meters[companion_id])
         _pending_meters.erase(companion_id)
     ```

  **Why erase after apply:** Prevents stale pending data from affecting future zone transitions. Each load populates pending, each register consumes it.

  **Backward compatibility:** `.get("health", {})` returns empty dict for old saves missing these keys. Empty dict means no pending health → companions keep their default values. No crash.

  **IMPORTANT:** Verify that CompanionBase has `set_health()` and `set_meter_value()` methods. If the methods are named differently, use the correct names. Check by reading the companion base class. The `get_current_health()` and `get_meter_value()` methods exist (called in `get_companions_for_ring()` at lines 126-129), so setters should exist too.

  If `set_health()` doesn't exist but `health_component.set_health()` does, use the health component:
  ```gdscript
  companion_node.health_component.set_health(_pending_health[companion_id])
  ```

  If `set_meter_value()` doesn't exist, look for `meter` or `unique_meter` properties and set directly.
  </action>
  <verify>
  1. Read party_manager.gd and confirm:
     - `_pending_health` and `_pending_meters` variables exist
     - `load_save_data()` stores data.get("health", {}) and data.get("meters", {})
     - `register_companion()` checks and applies pending values, then erases
  2. Verify companion node has the setter methods being called (set_health/set_meter_value or equivalent)
  3. Grep for `_pending_health` — should appear in: declaration, load_save_data, register_companion
  </verify>
  <done>Companion health and meters are stored as pending data on load, applied when companions register after zone loads, erased after application. Old saves without health/meters data load without crash.</done>
</task>

</tasks>

<verification>
1. Grep party_manager.gd for `_pending_health` — should appear 3+ times (declaration, store, apply, erase)
2. Grep party_manager.gd for `_pending_meters` — should appear 3+ times
3. Verify load_save_data() now reads health and meters keys from save data
4. Verify register_companion() applies and erases pending values
5. Verify backward compat: .get("health", {}) handles missing keys
</verification>

<success_criteria>
- Companion health values persist across save/load cycles
- Companion meter values persist across save/load cycles
- Old saves without health/meter data load without crash
- Deferred pattern matches existing SaveManager approach
- Only party_manager.gd modified (no other files)
</success_criteria>

<output>
After completion, create `.planning/phases/23-companion-save/23-01-SUMMARY.md`
</output>
