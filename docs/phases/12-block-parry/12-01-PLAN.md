---
phase: 12-block-parry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/guard/guard_component.gd
  - components/guard/guard_component.tscn
  - characters/player/states/player_block.gd
  - characters/player/player.gd
  - characters/player/player.tscn
  - autoloads/events.gd
autonomous: true

must_haves:
  truths:
    - "Player can hold block button to enter block state"
    - "Blocking reduces incoming damage by 50%"
    - "Guard meter depletes while blocking"
    - "Guard meter recharges when not blocking"
    - "Block breaks when guard meter empty"
  artifacts:
    - path: "components/guard/guard_component.gd"
      provides: "Guard meter logic"
      exports: ["GuardComponent"]
    - path: "characters/player/states/player_block.gd"
      provides: "Block state behavior"
      exports: ["PlayerBlock"]
  key_links:
    - from: "player_block.gd"
      to: "guard_component.gd"
      via: "guard.use_guard(delta)"
      pattern: "guard\\.use_guard"
    - from: "hurtbox"
      to: "guard_component"
      via: "damage reduction check"
      pattern: "is_blocking.*damage"
---

<objective>
Create the block state and guard meter system for defensive combat.

Purpose: Give players a defensive option that requires resource management (guard meter)
Output: Working block state with guard meter depletion/regen
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@characters/player/player.gd
@characters/player/states/player_dodge.gd
@components/hurtbox/hurtbox.gd
@autoloads/events.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GuardComponent</name>
  <files>
    components/guard/guard_component.gd
    components/guard/guard_component.tscn
  </files>
  <action>
Create GuardComponent following existing component patterns (like HealthComponent):

```gdscript
extends Node
class_name GuardComponent

signal guard_changed(current: float, max_guard: float)
signal guard_broken
signal guard_restored

@export var max_guard: float = 100.0
@export var guard_drain_rate: float = 30.0  # Per second while blocking
@export var guard_regen_rate: float = 20.0  # Per second when not blocking
@export var regen_delay: float = 1.0  # Seconds before regen starts

var current_guard: float = 100.0
var is_blocking: bool = false
var regen_timer: float = 0.0

func _ready() -> void:
    current_guard = max_guard

func _process(delta: float) -> void:
    if is_blocking:
        regen_timer = regen_delay
        use_guard(guard_drain_rate * delta)
    elif current_guard < max_guard:
        regen_timer -= delta
        if regen_timer <= 0:
            restore_guard(guard_regen_rate * delta)

func use_guard(amount: float) -> bool:
    if current_guard <= 0:
        return false
    current_guard = max(0, current_guard - amount)
    guard_changed.emit(current_guard, max_guard)
    if current_guard <= 0:
        guard_broken.emit()
        is_blocking = false
    return true

func restore_guard(amount: float) -> void:
    var was_empty = current_guard <= 0
    current_guard = min(max_guard, current_guard + amount)
    guard_changed.emit(current_guard, max_guard)
    if was_empty and current_guard > 0:
        guard_restored.emit()

func start_blocking() -> void:
    if current_guard > 0:
        is_blocking = true

func stop_blocking() -> void:
    is_blocking = false

func can_block() -> bool:
    return current_guard > 0

func get_damage_reduction() -> float:
    return 0.5 if is_blocking else 0.0
```

Create matching .tscn scene file with just the script attached.
  </action>
  <verify>
Files exist: `ls components/guard/`
Script has no syntax errors: Open in Godot, check for errors
  </verify>
  <done>GuardComponent with drain/regen logic exists and has no syntax errors</done>
</task>

<task type="auto">
  <name>Task 2: Create PlayerBlock state</name>
  <files>
    characters/player/states/player_block.gd
    autoloads/events.gd
  </files>
  <action>
Create PlayerBlock state following existing state patterns (like PlayerDodge):

```gdscript
extends State
class_name PlayerBlock

func enter() -> void:
    if not player.guard or not player.guard.can_block():
        state_machine.transition_to("Idle")
        return
    
    player.guard.start_blocking()
    player.velocity = Vector2.ZERO
    
    # Visual: darken sprite slightly to show blocking
    if player.sprite:
        player.sprite.color = Color(0.7, 0.7, 0.8, 1.0)
    
    Events.player_block_started.emit()

func exit() -> void:
    if player.guard:
        player.guard.stop_blocking()
    
    # Restore sprite color
    if player.sprite:
        player.sprite.color = Color.WHITE

func physics_update(_delta: float) -> void:
    # Stay in block while button held and guard available
    if not Input.is_action_pressed("block") or not player.guard.can_block():
        state_machine.transition_to("Idle")
        return
    
    # Can't move while blocking
    player.velocity = Vector2.ZERO
    player.move_and_slide()

func can_transition_to(state_name: String) -> bool:
    # Can transition to Hurt (if guard breaks or big hit)
    # Can transition to Idle (release block)
    return state_name in ["Idle", "Hurt", "Death"]
```

Add block signals to Events autoload:
- `signal player_block_started`
- `signal player_block_ended`
- `signal player_guard_broken`
  </action>
  <verify>
File exists: `ls characters/player/states/player_block.gd`
Events updated: `grep "block" autoloads/events.gd`
  </verify>
  <done>PlayerBlock state transitions properly, emits events</done>
</task>

<task type="auto">
  <name>Task 3: Integrate into Player</name>
  <files>
    characters/player/player.gd
    characters/player/player.tscn
    project.godot
  </files>
  <action>
1. Add input action "block" to project.godot (C key, or left mouse button alternative):
   - Input map: block -> C key

2. Update player.gd:
   - Add `@onready var guard: GuardComponent = $GuardComponent`
   - Add helper: `func is_blocking() -> bool: return guard and guard.is_blocking`

3. Update player.tscn:
   - Add GuardComponent as child node
   - Add PlayerBlock state to StateMachine

4. Update Hurtbox or hurt handling to check for blocking:
   In player.gd `_on_hurt()`:
   ```gdscript
   func _on_hurt(attacking_hitbox: Hitbox) -> void:
       var damage = attacking_hitbox.damage
       
       # Apply damage reduction if blocking
       if guard and guard.is_blocking:
           damage = int(damage * (1.0 - guard.get_damage_reduction()))
           # Small guard cost on hit while blocking
           guard.use_guard(10.0)
       
       if health:
           health.take_damage(damage)
       if health and not health.is_dead():
           # Only transition to Hurt if not blocking (or guard broke)
           if not (guard and guard.is_blocking):
               state_machine.transition_to("Hurt")
   ```

5. Update Idle state to transition to Block:
   In player_idle.gd, add check for block input -> transition to "Block"
  </action>
  <verify>
Run game, press C to block - player should stop moving, sprite darkens
Take damage while blocking - should be reduced by 50%
Hold block until guard depletes - should auto-exit block state
  </verify>
  <done>Block state fully integrated, damage reduction working, guard meter depletes</done>
</task>

</tasks>

<verification>
1. Run game with F5
2. Press C to enter block state (player stops, sprite darkens)
3. Release C to exit block state
4. Have enemy attack while blocking - damage should be halved
5. Hold block for ~3 seconds - guard should deplete and block should break
6. Wait after blocking - guard should regenerate
</verification>

<success_criteria>
- Block state activates on C key press
- Damage reduced by 50% while blocking
- Guard meter depletes at 30/sec while blocking
- Guard meter regenerates at 20/sec after 1s delay
- Block breaks automatically when guard empty
- Visual feedback (sprite color change) on block
</success_criteria>

<output>
After completion, create `.planning/phases/12-block-parry/12-01-SUMMARY.md`
</output>
