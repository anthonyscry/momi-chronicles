---
phase: 42-quest-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autoloads/quest_manager.gd
  - systems/quest/quest_objective.gd
  - systems/quest/quest_data.gd
  - characters/npcs/dialogue_npc.gd
  - ui/quest/quest_tracker.gd
  - ui/quest/quest_log.gd
  - components/quest_item_pickup/quest_item_pickup.gd
autonomous: true

must_haves:
  truths:
    - "Enemy kills advance elimination quest objectives"
    - "Item pickups advance fetch quest objectives"
    - "Return-to-NPC objectives only advance after prior objectives are complete"
    - "NPC quest markers work for all quest givers without hardcoded map"
    - "Quest tracker and log show progress counts for multi-count objectives"
    - "Quest rewards can include reputation gains"
    - "Quest item pickups are collectible Area2Ds in zones"
  artifacts:
    - path: "autoloads/quest_manager.gd"
      provides: "enemy_kill + item_collect trigger wiring, reputation rewards"
    - path: "systems/quest/quest_objective.gd"
      provides: "requires_prior_complete flag"
    - path: "systems/quest/quest_data.gd"
      provides: "quest_giver_id field"
    - path: "characters/npcs/dialogue_npc.gd"
      provides: "Data-driven quest marker lookup"
    - path: "components/quest_item_pickup/quest_item_pickup.gd"
      provides: "Collectible quest item component"
  key_links:
    - from: "autoloads/quest_manager.gd"
      to: "Events.enemy_defeated"
      via: "signal connection in _ready()"
    - from: "autoloads/quest_manager.gd"
      to: "Events.pickup_collected"
      via: "signal connection in _ready()"
    - from: "characters/npcs/dialogue_npc.gd"
      to: "QuestManager.available_quests"
      via: "dynamic quest_giver_id lookup"
    - from: "components/quest_item_pickup/quest_item_pickup.gd"
      to: "Events.pickup_collected"
      via: "emit on player collision"
---

<objective>
Extend the quest engine to support varied quest types (fetch, elimination, delivery, chain) by adding new trigger types, sequential objective ordering, data-driven NPC markers, a quest item pickup component, and progress display for count-based objectives.

Purpose: Phase 41 built the quest backend + UI with 2 sample quests using "dialogue" and "zone" triggers only. This plan adds the infrastructure needed for all 5 quest types before content is defined in Plan 42-02.
Output: Working quest engine supporting enemy_kill, item_collect, and sequential objectives; reusable quest pickup component; generalized NPC quest markers; progress counts in HUD.
</objective>

<context>
@docs/STATE.md
@docs/ROADMAP.md
@autoloads/quest_manager.gd
@systems/quest/quest_objective.gd
@systems/quest/quest_data.gd
@systems/quest/quest.gd
@characters/npcs/dialogue_npc.gd
@ui/quest/quest_tracker.gd
@ui/quest/quest_log.gd
@autoloads/events.gd
@components/pickup/coin_pickup.gd
@characters/enemies/enemy_base.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new trigger types + sequential objectives + reputation rewards + progress display</name>
  <files>
    autoloads/quest_manager.gd
    systems/quest/quest_objective.gd
    systems/quest/quest_data.gd
    ui/quest/quest_tracker.gd
    ui/quest/quest_log.gd
  </files>
  <action>
**quest_objective.gd — Add requires_prior_complete flag:**
- Add property: `var requires_prior_complete: bool = false` after the `current_count` property
- Update `_init()` signature to accept `p_requires_prior_complete: bool = false` as the last parameter
- Set `self.requires_prior_complete = p_requires_prior_complete` in _init
- Update `to_dict()` to include `"requires_prior_complete": requires_prior_complete`
- Update `from_dict()` to load: `requires_prior_complete = data.get("requires_prior_complete", false)`

**quest_data.gd — Add quest_giver_id + requires_prior_complete arrays:**
- Add `@export var quest_giver_id: String = ""` after `zone_unlock` (which NPC gives/turns-in this quest)
- Add `@export var objective_requires_prior: Array[bool] = []` after `objective_target_counts`
- In `create_quest()`, after the target_count handling (around line 74), add:
  ```
  var requires_prior: bool = false
  if i < objective_requires_prior.size():
      requires_prior = objective_requires_prior[i]
  ```
- Pass `requires_prior` as the 7th arg to QuestObjective.new(): `QuestObjective.new(obj_description, false, is_optional, trigger_type, trigger_id, target_count, requires_prior)`

**quest_manager.gd — Wire enemy_kill + item_collect + reputation rewards:**

In `_ready()`, after the existing zone_entered connection (around line 56), add:
```
Events.enemy_defeated.connect(_on_enemy_defeated_for_quests)
Events.pickup_collected.connect(_on_pickup_collected_for_quests)
```

Add new handler functions after `_check_zone_objectives()`:

```gdscript
func _on_enemy_defeated_for_quests(enemy: Node) -> void:
    # Extract enemy type from script path: "res://characters/enemies/raccoon.gd" -> "raccoon"
    var enemy_type: String = "unknown"
    if enemy and is_instance_valid(enemy) and enemy.get_script():
        enemy_type = enemy.get_script().resource_path.get_file().get_basename()
    _check_enemy_kill_objectives(enemy_type)

func _on_pickup_collected_for_quests(item_id: String, _amount: int) -> void:
    _check_item_collect_objectives(item_id)

func _check_enemy_kill_objectives(enemy_type: String) -> void:
    for quest_id in active_quests.keys():
        var quest: Quest = active_quests[quest_id]
        for i in range(quest.objectives.size()):
            var obj: QuestObjective = quest.objectives[i]
            if obj.trigger_type == "enemy_kill" and not obj.is_completed():
                # Check requires_prior_complete
                if obj.requires_prior_complete:
                    var blocked = false
                    for j in range(i):
                        if not quest.objectives[j].is_completed():
                            blocked = true
                            break
                    if blocked:
                        continue
                # "any" matches all enemy types, otherwise match specific type
                if obj.trigger_id == "any" or obj.trigger_id == enemy_type:
                    if obj.advance():
                        DebugLogger.log_system("Quest objective advanced: %s [%d] — %s (%d/%d)" % [quest_id, i, obj.description, obj.current_count, obj.target_count])
                    quest_updated.emit(quest_id, i)
                    Events.quest_updated.emit(quest_id, i)
                    if quest.all_objectives_completed():
                        complete_quest(quest_id)

func _check_item_collect_objectives(item_id: String) -> void:
    for quest_id in active_quests.keys():
        var quest: Quest = active_quests[quest_id]
        for i in range(quest.objectives.size()):
            var obj: QuestObjective = quest.objectives[i]
            if obj.trigger_type == "item_collect" and obj.trigger_id == item_id and not obj.is_completed():
                # Check requires_prior_complete
                if obj.requires_prior_complete:
                    var blocked = false
                    for j in range(i):
                        if not quest.objectives[j].is_completed():
                            blocked = true
                            break
                    if blocked:
                        continue
                if obj.advance():
                    DebugLogger.log_system("Quest objective completed: %s [%d] — %s" % [quest_id, i, obj.description])
                    quest_updated.emit(quest_id, i)
                    Events.quest_updated.emit(quest_id, i)
                    if quest.all_objectives_completed():
                        complete_quest(quest_id)
```

Also update `_check_dialogue_objectives()` and `_check_zone_objectives()` to respect `requires_prior_complete`:
- In each function, BEFORE the `if obj.advance()` call, add the same prior-complete check:
```gdscript
if obj.requires_prior_complete:
    var blocked = false
    for j in range(i):
        if not quest.objectives[j].is_completed():
            blocked = true
            break
    if blocked:
        continue
```

**Reputation rewards in _grant_rewards():**
After the equipment reward block (around line 353), add:
```gdscript
# Grant reputation
if rewards.has("reputation") and rewards["reputation"] is Dictionary:
    var rep_data: Dictionary = rewards["reputation"]
    for npc_id in rep_data:
        if has_node("/root/GameManager"):
            var game_manager = get_node("/root/GameManager")
            game_manager.add_reputation(npc_id, int(rep_data[npc_id]))
            DebugLogger.log_system("QuestManager: Granted +%d reputation with '%s'" % [int(rep_data[npc_id]), npc_id])
```

**quest_tracker.gd — Show progress counts:**
In `_update_display()` around line 94-96, change the objective display to show count progress:
```gdscript
var current_objective = current_quest.get_current_objective()
if current_objective:
    if current_objective.target_count > 1:
        objective_label.text = "%s (%d/%d)" % [current_objective.description, current_objective.current_count, current_objective.target_count]
    else:
        objective_label.text = current_objective.description
```

**quest_log.gd — Show progress counts in objectives list:**
In `_create_quest_entry()` around line 162, update the objective text:
```gdscript
var progress_text = ""
if objective.target_count > 1:
    progress_text = " (%d/%d)" % [objective.current_count, objective.target_count]
obj_label.text = "[%s] %s%s%s" % [checkbox, objective.description, progress_text, optional_tag]
```
  </action>
  <verify>
- Open quest_objective.gd and confirm `requires_prior_complete` property exists with serialization
- Open quest_data.gd and confirm `quest_giver_id` and `objective_requires_prior` exports exist
- Open quest_manager.gd and confirm `_on_enemy_defeated_for_quests`, `_on_pickup_collected_for_quests`, `_check_enemy_kill_objectives`, `_check_item_collect_objectives` functions exist
- Open quest_manager.gd and confirm reputation handling in `_grant_rewards`
- Verify requires_prior_complete check exists in all 4 objective checker functions
- Open quest_tracker.gd and confirm count display logic
- Open quest_log.gd and confirm count display in objective text
  </verify>
  <done>
- QuestObjective has requires_prior_complete flag (default false, backward compatible)
- QuestData has quest_giver_id field + objective_requires_prior array
- QuestManager wires Events.enemy_defeated → _check_enemy_kill_objectives (supports "any" and specific types)
- QuestManager wires Events.pickup_collected → _check_item_collect_objectives
- All 4 objective checkers respect requires_prior_complete flag
- _grant_rewards handles "reputation" reward dict ({npc_id: amount})
- QuestTracker shows "Objective (3/5)" for multi-count objectives
- QuestLog shows "[✓] Objective (3/5)" for multi-count objectives
  </done>
</task>

<task type="auto">
  <name>Task 2: Generalize NPC quest markers to be data-driven</name>
  <files>
    characters/npcs/dialogue_npc.gd
    autoloads/quest_manager.gd
  </files>
  <action>
**dialogue_npc.gd — Replace hardcoded npc_quest_map:**

In `_update_quest_marker()`, remove the hardcoded dictionary (lines ~207-215):
```gdscript
# DELETE THIS:
var npc_quest_map: Dictionary = {
    "gertrude": "meet_neighbors",
    "maurice": "community_watch",
}
if npc_quest_map.has(dialogue_id):
    var mapped_quest = npc_quest_map[dialogue_id]
    if QuestManager.can_start_quest(mapped_quest):
        show_exclamation = true
```

Replace with a dynamic lookup:
```gdscript
# Check if talking to this NPC would start any available quest
# Uses quest_giver_id from QuestData for data-driven marker display
for qid in QuestManager.available_quests.keys():
    var qdata = QuestManager.available_quests[qid]
    if qdata.quest_giver_id == dialogue_id and QuestManager.can_start_quest(qid):
        show_exclamation = true
        break
```

Also update the "?" marker check to respect requires_prior_complete:
```gdscript
# Check if this NPC has a "dialogue" objective in any active quest
# Only show "?" if the objective can actually advance (not blocked by prior objectives)
for qid in QuestManager.active_quests.keys():
    var quest = QuestManager.get_active_quest(qid)
    if quest:
        for obj_idx in range(quest.objectives.size()):
            var obj = quest.objectives[obj_idx]
            if obj.trigger_type == "dialogue" and obj.trigger_id == dialogue_id and not obj.is_completed():
                # Check if blocked by requires_prior_complete
                var blocked = false
                if obj.requires_prior_complete:
                    for j in range(obj_idx):
                        if not quest.objectives[j].is_completed():
                            blocked = true
                            break
                if not blocked:
                    show_question = true
                    break
        if show_question:
            break
```

**quest_manager.gd — Update existing quests with quest_giver_id:**

In `_register_all_quests()`, after each quest's data setup, set quest_giver_id:
- For q1 (meet_neighbors): `q1.quest_giver_id = "gertrude"` (after line ~431, before register_quest_data)
- For q2 (community_watch): `q2.quest_giver_id = "maurice"` (after line ~446, before register_quest_data)

Note: The dialogue_id for gertrude NPC in neighborhood.gd is "gertrude_start", but the quest trigger in _on_dialogue_started_for_quests extracts the base dialogue_id. Check the dialogue ID extraction — the existing code uses:
```gdscript
for did in DialogueManager._dialogues:
    if DialogueManager._dialogues[did] == dialogue:
        dialogue_id = did
        break
```
This gets the raw dialogue_id like "gertrude_start". But the quest_giver_id should match the dialogue_npc.dialogue_id property. Looking at neighborhood.gd, the NPCs use dialogue_ids like "gertrude_start", "maurice_start", "kids_start", "henderson_grumpy/warming/friendly". 

However, the _update_quest_marker in dialogue_npc.gd uses `self.dialogue_id` which is the NPC's configured dialogue_id. This can change (Henderson changes based on rep). The quest_giver_id needs to be a STABLE identifier for the NPC, not the dialogue variant.

**Solution:** Use the NPC's base name as the quest_giver_id, and match it against the first part of dialogue_id. OR simpler: add an `npc_id` property to dialogue_npc.gd that's stable (separate from dialogue_id which changes).

Add to dialogue_npc.gd:
```gdscript
## Stable NPC identifier for quest system (doesn't change with dialogue variants)
@export var npc_id: String = ""
```

In `_update_quest_marker()`, use `npc_id` instead of `dialogue_id` for quest lookups:
```gdscript
var lookup_id = npc_id if not npc_id.is_empty() else dialogue_id
```

Use `lookup_id` for both the "!" (quest_giver_id match) and "?" (dialogue trigger_id match) checks.

Update neighborhood.gd's `_create_dialogue_npc()` to also set npc_id. Or better: set npc_id in the build functions:
- After `_create_dialogue_npc("Gertrude", "gertrude_start", ...)`, add `.npc_id = "gertrude"`
- After `_create_dialogue_npc("Maurice", "maurice_start", ...)`, add `.npc_id = "maurice"`
- After `_create_dialogue_npc("Kids Gang", "kids_start", ...)`, add `.npc_id = "kids_gang"`
- After `_create_dialogue_npc("Mr. Henderson", dialogue_id, ...)`, add `.npc_id = "henderson"`

Actually, looking at the code, _create_dialogue_npc returns the npc node. The build functions use it:
```gdscript
func _build_gertrude() -> void:
    _create_dialogue_npc("Gertrude", "gertrude_start", Color(0.7, 0.5, 0.7), Vector2(120, 220))
```

Change to:
```gdscript
func _build_gertrude() -> void:
    var npc = _create_dialogue_npc("Gertrude", "gertrude_start", Color(0.7, 0.5, 0.7), Vector2(120, 220))
    npc.npc_id = "gertrude"
```

Do the same for all 4 NPCs. Henderson already stores the ref in `_henderson_npc`:
```gdscript
func _build_henderson() -> void:
    ...
    _henderson_npc = _create_dialogue_npc(...)
    _henderson_npc.npc_id = "henderson"
```

Also update quest_manager.gd — the _on_dialogue_started_for_quests and _check_dialogue_objectives need to use npc_id when checking objectives. Currently they extract dialogue_id from DialogueManager. We also need to match trigger_ids against npc_id. 

The cleanest approach: quest objective trigger_ids for "dialogue" type use the stable npc_id (e.g., "maurice", "gertrude", "henderson"), NOT the dialogue variant ID. The existing quests already use this pattern (trigger_id: "maurice", "kids_gang", "henderson"). 

The _on_dialogue_started_for_quests extracts dialogue_id from DialogueManager._dialogues which gives "gertrude_start", "maurice_start", etc. This doesn't match "gertrude", "maurice". 

Wait — looking at the existing code more carefully:
```gdscript
# Check if talking to this NPC should START a quest
if dialogue_id == "gertrude" and can_start_quest("meet_neighbors"):
```

But the dialogue_id extracted from DialogueManager would be "gertrude_start" (that's the key used to load the dialogue JSON). So this hardcoded check `dialogue_id == "gertrude"` would NEVER match if the actual key is "gertrude_start"!

Let me check the dialogue loading. In neighborhood.gd:
```gdscript
DialogueManager.load_dialogue_file("res://resources/dialogues/gertrude.json")
```

The load_dialogue_file function probably uses the filename as the key. Let me check.

Actually, I should check what DialogueManager._dialogues keys look like. But I don't have DialogueManager source. However, the existing quests DO work (they were tested in Phase 41), so the dialogue_id extraction must produce the right values. The dialogue JSON files are named gertrude.json, maurice.json, etc. If DialogueManager uses the filename without extension as the key, then `_dialogues` would have keys like "gertrude", "maurice", "kids_gang", "henderson".

But then why are the dialogue_ids in _create_dialogue_npc set to "gertrude_start", "maurice_start", etc.? 

Looking at _create_dialogue_npc:
```gdscript
npc.dialogue_id = npc_dialogue_id  # e.g., "gertrude_start"
```

And in _start_dialogue:
```gdscript
DialogueManager.start_dialogue(dialogue_id)  # passes "gertrude_start"
```

So DialogueManager.start_dialogue receives "gertrude_start". But _dialogues might be keyed by "gertrude" (filename). This means start_dialogue might do a lookup where "gertrude_start" is a node WITHIN the "gertrude" dialogue tree.

I think the dialogue system works like: load_dialogue_file("gertrude.json") loads a tree, and start_dialogue("gertrude_start") starts at the node named "gertrude_start" within that tree. The _dialogues dict is probably keyed by the file-based ID.

Looking at the quest manager's extraction:
```gdscript
for did in DialogueManager._dialogues:
    if DialogueManager._dialogues[did] == dialogue:
        dialogue_id = did
        break
```

This matches the dialogue object passed to the signal against _dialogues entries. If _dialogues is keyed by "gertrude" and the value is the dialogue resource, then `dialogue_id` would be "gertrude".

Then the hardcoded check `if dialogue_id == "gertrude"` would match. And the objective trigger_ids are "maurice", "kids_gang", "henderson" which would also match.

OK so the existing system already uses the base dialogue ID (not the start node). The npc_id approach is still cleaner though — it decouples quest identification from dialogue system internals.

For the quest_giver_id, I'll use the same identifiers: "gertrude", "maurice", "kids_gang", "henderson".

For the auto-start logic, I'll generalize it. Instead of hardcoded if-statements, check all available quests: if quest.quest_giver_id matches the current dialogue npc_id, and can_start_quest, start it.

Update _on_dialogue_started_for_quests:
```gdscript
func _on_dialogue_started_for_quests(dialogue) -> void:
    var dialogue_id: String = ""
    if dialogue:
        for did in DialogueManager._dialogues:
            if DialogueManager._dialogues[did] == dialogue:
                dialogue_id = did
                break
    if dialogue_id.is_empty():
        return
    
    # Auto-start quests where this NPC is the quest giver
    for qid in available_quests.keys():
        var qdata: QuestData = available_quests[qid]
        if qdata.quest_giver_id == dialogue_id and can_start_quest(qid):
            start_quest(qid)
            DebugLogger.log_system("Quest auto-started: %s (talked to %s)" % [qid, dialogue_id])
    
    # Complete "talk to" objectives for active quests
    _check_dialogue_objectives(dialogue_id)
```

This replaces the hardcoded gertrude→meet_neighbors and maurice→community_watch checks with a generic loop. Much cleaner and works for all future quests.
  </action>
  <verify>
- In dialogue_npc.gd: confirm `npc_id` export property exists, hardcoded npc_quest_map is removed, dynamic lookup uses quest_giver_id
- In quest_manager.gd: confirm q1.quest_giver_id = "gertrude", q2.quest_giver_id = "maurice"
- In quest_manager.gd: confirm _on_dialogue_started_for_quests uses generic quest_giver_id loop instead of hardcoded if-statements
- In dialogue_npc.gd: confirm "?" marker respects requires_prior_complete
- In neighborhood.gd: confirm all 4 NPCs have npc_id set
  </verify>
  <done>
- dialogue_npc.gd has stable `npc_id` export, quest marker lookup is fully data-driven
- Hardcoded npc_quest_map removed from dialogue_npc.gd
- Quest auto-start in _on_dialogue_started_for_quests is generic (iterates quest_giver_id matches)
- All 4 neighborhood NPCs have npc_id set (gertrude, maurice, kids_gang, henderson)
- Existing quests have quest_giver_id populated
- NPC "?" marker respects requires_prior_complete for sequenced objectives
  </done>
</task>

<task type="auto">
  <name>Task 3: Create quest item pickup component</name>
  <files>
    components/quest_item_pickup/quest_item_pickup.gd
  </files>
  <action>
Create a new directory `components/quest_item_pickup/` and file `quest_item_pickup.gd`.

This is a collectible Area2D that emits Events.pickup_collected when the player touches it. It follows the coin_pickup.gd pattern but is quest-specific.

```gdscript
extends Area2D
## A quest-specific collectible item.
## Emits Events.pickup_collected(item_id, 1) when player touches it.
## Optionally only visible/active when a specific quest is active.
##
## Usage: Create via code, set item_id and optionally quest_id, add to scene.

# Configuration
@export var item_id: String = ""         # Pickup identifier (matches quest objective trigger_id)
@export var quest_id: String = ""        # If set, only visible/active when this quest is active
@export var pickup_color: Color = Color(0.3, 0.9, 0.5)  # Visual color
@export var label_text: String = ""      # Optional floating label text

# State
var _collected: bool = false
var _bob_time: float = 0.0
var _base_y: float = 0.0
var _visual: Polygon2D = null
var _label: Label = null

func _ready() -> void:
    add_to_group("quest_items")
    collision_layer = 0
    collision_mask = 2  # Player layer
    body_entered.connect(_on_body_entered)
    _base_y = position.y

    _create_collision_shape()
    _create_visual()
    if not label_text.is_empty():
        _create_label()

    # If quest-gated, check visibility
    if not quest_id.is_empty():
        _update_visibility()
        Events.quest_started.connect(func(_qid): _update_visibility())
        Events.quest_completed.connect(func(_qid): _update_visibility())


func _process(delta: float) -> void:
    if _collected:
        return
    # Gentle bob animation
    _bob_time += delta
    if _visual:
        _visual.position.y = sin(_bob_time * 2.5) * 2.0
    # Sparkle rotation
    if _visual:
        _visual.rotation += delta * 0.5


func _create_collision_shape() -> void:
    var shape = CollisionShape2D.new()
    var circle = CircleShape2D.new()
    circle.radius = 10.0
    shape.shape = circle
    add_child(shape)


func _create_visual() -> void:
    # Diamond shape (rotated square)
    _visual = Polygon2D.new()
    _visual.polygon = PackedVector2Array([
        Vector2(0, -6),  # top
        Vector2(5, 0),   # right
        Vector2(0, 6),   # bottom
        Vector2(-5, 0),  # left
    ])
    _visual.color = pickup_color
    _visual.z_index = 3
    add_child(_visual)

    # Inner highlight
    var highlight = Polygon2D.new()
    highlight.polygon = PackedVector2Array([
        Vector2(0, -3),
        Vector2(2.5, 0),
        Vector2(0, 3),
        Vector2(-2.5, 0),
    ])
    highlight.color = pickup_color.lightened(0.4)
    highlight.z_index = 4
    add_child(highlight)


func _create_label() -> void:
    _label = Label.new()
    _label.text = label_text
    _label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
    _label.position = Vector2(-20, -18)
    _label.size = Vector2(40, 12)
    _label.add_theme_font_size_override("font_size", 6)
    _label.add_theme_color_override("font_color", Color(1, 1, 0.9, 0.8))
    _label.add_theme_color_override("font_shadow_color", Color(0, 0, 0, 0.6))
    _label.add_theme_constant_override("shadow_offset_x", 1)
    _label.add_theme_constant_override("shadow_offset_y", 1)
    add_child(_label)


func _update_visibility() -> void:
    if quest_id.is_empty():
        visible = true
        return
    # Only show if the quest is active
    if has_node("/root/QuestManager"):
        visible = QuestManager.is_quest_active(quest_id)
    else:
        visible = false


func _on_body_entered(body: Node2D) -> void:
    if _collected:
        return
    if not body.is_in_group("player"):
        return
    if not visible:
        return

    _collected = true

    # Emit pickup event for quest system
    Events.pickup_collected.emit(item_id, 1)
    DebugLogger.log_system("Quest item collected: %s" % item_id)

    # Collection animation: scale up + fade out
    var tween = create_tween()
    tween.parallel().tween_property(self, "scale", Vector2(1.5, 1.5), 0.2).set_ease(Tween.EASE_OUT)
    tween.parallel().tween_property(self, "modulate:a", 0.0, 0.2)
    tween.tween_callback(queue_free)
```

**Important implementation notes:**
- Follows coin_pickup.gd pattern (Area2D + body_entered + group)
- Does NOT use class_name (project convention: path-based extends)
- Uses DebugLogger (not print)
- Quest-gated visibility: hidden until quest is active, auto-hides when quest completes
- Diamond shape visual matches pixel art aesthetic (simple geometric)
  </action>
  <verify>
- File exists at components/quest_item_pickup/quest_item_pickup.gd
- Script extends Area2D, has item_id/quest_id exports
- Emits Events.pickup_collected(item_id, 1) on player collision
- Has quest-gated visibility logic
- Uses DebugLogger, not print()
- Does not use class_name
  </verify>
  <done>
- quest_item_pickup.gd exists as reusable Area2D component
- Emits Events.pickup_collected on player touch
- Quest-gated: only visible when associated quest is active
- Visual: colored diamond with bob + rotation animation
- Collection animation: scale up + fade out → queue_free
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run the game — no crash on startup (quest system initializes cleanly)
2. Verify existing quests still work: talk to Gertrude → meet_neighbors starts, objectives track correctly
3. Confirm QuestTracker shows progress counts for multi-count objectives
4. Confirm NPC quest markers appear without hardcoded map (data-driven from quest_giver_id)
</verification>

<success_criteria>
- New trigger types (enemy_kill, item_collect) wired and functional
- Sequential objective ordering works (requires_prior_complete flag)
- NPC quest markers are fully data-driven (no hardcoded npc_quest_map)
- Quest item pickup component exists and emits correct signals
- Progress counts shown in tracker ("3/5") and log ("[✓] Task (3/5)")
- Reputation rewards handled in _grant_rewards
- All changes backward-compatible (existing 2 quests still work)
</success_criteria>

<output>
After completion, create `docs/phases/42-quest-types/42-01-SUMMARY.md`
</output>
