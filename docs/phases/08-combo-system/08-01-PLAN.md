---
phase: 08-combo-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - characters/player/states/player_attack.gd
  - characters/player/states/player_combo_attack.gd (NEW)
  - characters/player/player.gd
  - characters/player/player.tscn
autonomous: true

must_haves:
  truths:
    - "Player can chain 3 attacks in sequence"
    - "Combo resets if timing window missed"
    - "Each hit in combo deals more damage"
  artifacts:
    - path: "characters/player/states/player_combo_attack.gd"
      provides: "Combo state machine logic"
    - path: "characters/player/player.gd"
      provides: "Combo state integration"
  key_links:
    - from: "player_combo_attack.gd"
      to: "StateMachine"
      via: "transition_to with combo_index"
---

<objective>
Implement 3-hit combo attack chain with timing windows and damage scaling.

Purpose: Make combat feel fluid and rewarding with skill-based combo execution
Output: Working combo system (Attack1 → Attack2 → Attack3) with timing windows
</objective>

<context>
@characters/player/states/player_attack.gd (current attack state to extend)
@characters/player/player.gd (player class)
@components/state_machine/state_machine.gd (state transitions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Combo Attack State</name>
  <files>characters/player/states/player_combo_attack.gd</files>
  <action>
Create new state `PlayerComboAttack` that replaces/extends PlayerAttack:

```gdscript
extends State
class_name PlayerComboAttack

# Combo configuration
const COMBO_DATA = [
    {"duration": 0.3, "damage_mult": 1.0, "hitbox_start": 0.08, "hitbox_end": 0.22},   # Hit 1: Quick jab
    {"duration": 0.35, "damage_mult": 1.25, "hitbox_start": 0.1, "hitbox_end": 0.25},  # Hit 2: Swipe
    {"duration": 0.45, "damage_mult": 1.75, "hitbox_start": 0.12, "hitbox_end": 0.35}  # Hit 3: Power bite
]
const COMBO_WINDOW: float = 0.4  # Seconds to input next attack
const BASE_DAMAGE: int = 25

var combo_index: int = 0
var attack_timer: float = 0.0
var hitbox_active: bool = false
var can_chain: bool = false  # True when combo window is open
var chain_requested: bool = false  # Player pressed attack during window
```

Key mechanics:
- Track `combo_index` (0, 1, 2) for current hit
- After hitbox_end, open `can_chain` window for COMBO_WINDOW duration
- If player presses attack during window, set `chain_requested = true`
- When attack_timer >= duration:
  - If chain_requested AND combo_index < 2: increment combo_index, restart attack_timer
  - Else: transition to Idle, reset combo_index to 0
- Damage = BASE_DAMAGE * COMBO_DATA[combo_index].damage_mult
- Position hitbox based on facing (reuse logic from player_attack.gd)
  </action>
  <verify>File exists with combo logic, extends State class</verify>
  <done>PlayerComboAttack state handles 3-hit chain with timing windows</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Combo State into Player</name>
  <files>characters/player/player.gd, characters/player/player.tscn</files>
  <action>
1. In player.tscn StateMachine node:
   - Add new child node: ComboAttack (Script: player_combo_attack.gd)
   
2. In player.gd, add combo tracking:
```gdscript
var current_combo_count: int = 0  # For UI/effects

func get_combo_count() -> int:
    return current_combo_count

func set_combo_count(count: int) -> void:
    current_combo_count = count
    Events.combo_changed.emit(count)  # We'll add this signal
```

3. Update any state that transitions to "Attack" to now transition to "ComboAttack"
   - In player_idle.gd: change "Attack" → "ComboAttack"
   - In player_walk.gd: change "Attack" → "ComboAttack"  
   - In player_run.gd: change "Attack" → "ComboAttack"
  </action>
  <verify>Run game, press attack repeatedly - should see combo chain (damage numbers increase)</verify>
  <done>ComboAttack state integrated, old Attack transitions updated</done>
</task>

<task type="auto">
  <name>Task 3: Add Combo Signal to Events</name>
  <files>autoloads/events.gd</files>
  <action>
Add combo-related signals:

```gdscript
# =============================================================================
# COMBO SIGNALS
# =============================================================================

## Emitted when combo count changes
signal combo_changed(combo_count: int)

## Emitted when combo chain completes (all 3 hits landed)
signal combo_completed(total_damage: int)

## Emitted when combo drops (missed timing)
signal combo_dropped
```
  </action>
  <verify>Events.gd has combo signals</verify>
  <done>Combo signals available for UI integration</done>
</task>

</tasks>

<verification>
1. Run game with F5
2. Attack enemy 3 times quickly → damage numbers should be: 25, 31, 43 (approx)
3. Attack once, wait 0.5s, attack again → damage resets to 25 (combo dropped)
4. Check console for any errors during combo execution
</verification>

<success_criteria>
- 3-hit combo works with timing window
- Damage scales: 1x → 1.25x → 1.75x
- Combo resets on missed timing
- No crashes or state machine issues
</success_criteria>

<output>
After completion, create `.planning/phases/08-combo-system/08-01-SUMMARY.md`
</output>
