---
phase: 20-mini-bosses
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - characters/enemies/mini_boss_base.gd
  - characters/enemies/states/mini_boss_idle.gd
  - autoloads/events.gd
  - autoloads/save_manager.gd
  - autoloads/game_manager.gd
  - systems/equipment/equipment_database.gd
  - ui/hud/boss_health_bar.gd
autonomous: true

must_haves:
  truths:
    - "Mini-boss base class exists and extends EnemyBase with attack pattern cycling"
    - "Events bus has mini_boss_spawned and mini_boss_defeated signals"
    - "SaveManager persists mini_bosses_defeated dictionary across save/load"
    - "GameManager tracks mini_bosses_defeated and auto-saves on defeat"
    - "BossHealthBar responds to mini-boss signals with mid-size display"
    - "EquipmentDatabase contains 3 rare mini-boss loot items"
  artifacts:
    - path: "characters/enemies/mini_boss_base.gd"
      provides: "MiniBossBase class extending EnemyBase"
      contains: "class_name MiniBossBase"
    - path: "characters/enemies/states/mini_boss_idle.gd"
      provides: "MiniBossIdle state with attack pattern cycling"
      contains: "class_name MiniBossIdle"
    - path: "autoloads/events.gd"
      provides: "Mini-boss signals"
      contains: "signal mini_boss_spawned"
    - path: "autoloads/save_manager.gd"
      provides: "mini_bosses_defeated in save data"
      contains: "mini_bosses_defeated"
    - path: "autoloads/game_manager.gd"
      provides: "Mini-boss defeat tracking and auto-save"
      contains: "mini_bosses_defeated"
    - path: "systems/equipment/equipment_database.gd"
      provides: "3 rare equipment items for mini-boss loot"
      contains: "raccoon_crown"
    - path: "ui/hud/boss_health_bar.gd"
      provides: "Mini-boss health bar support"
      contains: "mini_boss_spawned"
  key_links:
    - from: "characters/enemies/mini_boss_base.gd"
      to: "autoloads/events.gd"
      via: "Events.mini_boss_spawned.emit / Events.mini_boss_defeated.emit"
      pattern: "Events\\.mini_boss_"
    - from: "autoloads/game_manager.gd"
      to: "autoloads/save_manager.gd"
      via: "mini_bosses_defeated dict gathered/applied in save"
      pattern: "mini_bosses_defeated"
    - from: "ui/hud/boss_health_bar.gd"
      to: "autoloads/events.gd"
      via: "Events.mini_boss_spawned.connect / Events.mini_boss_defeated.connect"
      pattern: "mini_boss_spawned\\.connect"
---

<objective>
Build the mini-boss system foundation: MiniBossBase class, MiniBossIdle state, Events signals, SaveManager persistence, GameManager tracking, EquipmentDatabase rare loot, and BossHealthBar adaptation for mini-boss encounters.

Purpose: All 3 mini-bosses (Plans 02-04) depend on this shared infrastructure. Creating it first enables parallel development of all 3 mini-bosses.
Output: Shared classes and system integrations that Plans 02-04 extend.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-mini-bosses/20-RESEARCH.md

Key source files to reference:
@characters/enemies/enemy_base.gd — base class to extend
@characters/enemies/boss_raccoon_king.gd — boss pattern reference (attack cycling, enrage, death)
@characters/enemies/states/boss_idle.gd — boss idle pattern reference
@components/state_machine/state.gd — State base class (has `var player`, NOT `var enemy`)
@components/state_machine/state_machine.gd — StateMachine init sets child.player = entity
@autoloads/events.gd — signal bus to extend
@autoloads/save_manager.gd — save system to extend
@autoloads/game_manager.gd — game state to extend
@systems/equipment/equipment_database.gd — equipment DB to extend
@ui/hud/boss_health_bar.gd — health bar to adapt
</context>

<tasks>

<task type="auto">
  <name>Task 1: MiniBossBase class, MiniBossIdle state, and Events signals</name>
  <files>
    characters/enemies/mini_boss_base.gd
    characters/enemies/states/mini_boss_idle.gd
    autoloads/events.gd
  </files>
  <action>
**1. Add mini-boss signals to `autoloads/events.gd`:**

After the existing BOSS SIGNALS section (after line ~119 `signal boss_defeated`), add a new section:

```gdscript
# =============================================================================
# MINI-BOSS SIGNALS
# =============================================================================

## Emitted when a mini-boss spawns (boss: the mini-boss node, boss_name: display name)
signal mini_boss_spawned(boss: Node, boss_name: String)

## Emitted when a mini-boss is defeated (boss: the mini-boss node, boss_key: save key)
signal mini_boss_defeated(boss: Node, boss_key: String)
```

**2. Create `characters/enemies/mini_boss_base.gd`:**

This extends EnemyBase (path-based) and sits between EnemyBase and specific mini-bosses.

```gdscript
extends "res://characters/enemies/enemy_base.gd"
class_name MiniBossBase
## Base class for all mini-boss enemies.
## Extends EnemyBase with attack pattern cycling, one-time defeat tracking,
## unique loot drops, and mini-boss health bar integration.

# =============================================================================
# MINI-BOSS CONFIGURATION
# =============================================================================

## Display name shown on health bar
@export var boss_name: String = "Mini-Boss"

## Save key for one-time defeat tracking (e.g., "alpha_raccoon")
@export var is_defeated_key: String = ""

## Equipment ID to grant on defeat (from EquipmentDatabase)
@export var loot_equipment_id: String = ""

# =============================================================================
# ATTACK PATTERN SYSTEM
# =============================================================================

## Array of state names to cycle through (e.g., ["AlphaSlam", "AlphaSummon"])
var attack_patterns: Array[String] = []
var current_attack_index: int = 0

# =============================================================================
# MINI-BOSS STATE
# =============================================================================

var is_mini_boss: bool = true
var defeat_tracked: bool = false

## Track spawned reinforcements for cleanup on death
var spawned_minions: Array[Node] = []

# =============================================================================
# LIFECYCLE
# =============================================================================

func _ready() -> void:
    super._ready()
    add_to_group("mini_bosses")
    
    # Remove the small enemy health bar — mini-boss uses the HUD bar
    if health_bar:
        health_bar.queue_free()
        health_bar = null
    
    # Emit spawn event for HUD health bar
    Events.mini_boss_spawned.emit(self, boss_name)

# =============================================================================
# ATTACK PATTERN CYCLING
# =============================================================================

## Get the next attack state name (cycles through attack_patterns array)
func get_next_attack_state() -> String:
    if attack_patterns.is_empty():
        return "MiniBossIdle"
    var state_name = attack_patterns[current_attack_index]
    current_attack_index = (current_attack_index + 1) % attack_patterns.size()
    return state_name

## Alias for BossIdle pattern compatibility — BossIdle calls get_attack_state_name()
func get_attack_state_name() -> String:
    return get_next_attack_state()

# =============================================================================
# DEATH OVERRIDE
# =============================================================================

func _on_died() -> void:
    # Emit mini-boss defeat signal (NOT boss_defeated — separate signal)
    Events.mini_boss_defeated.emit(self, is_defeated_key)
    
    # Grant equipment loot
    _grant_loot()
    
    # Spawn regular drops (coins, health)
    _spawn_drops()
    
    # Clean up spawned reinforcements
    _cleanup_minions()
    
    # Play mini-boss death sequence (lighter than full boss)
    _play_mini_boss_death()

## Grant rare equipment on defeat
func _grant_loot() -> void:
    if loot_equipment_id.is_empty():
        return
    if GameManager.equipment_manager:
        GameManager.equipment_manager.add_equipment(loot_equipment_id)
    # Show floating notification
    _show_loot_notification()

## Show floating text notification for loot
func _show_loot_notification() -> void:
    var equip_data = EquipmentDatabase.get_equipment(loot_equipment_id)
    if equip_data.is_empty():
        return
    var label = Label.new()
    label.text = "Got %s!" % equip_data.get("name", "???")
    label.add_theme_font_size_override("font_size", 10)
    label.add_theme_color_override("font_color", Color(1, 0.85, 0.2))  # Gold
    label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
    label.position = Vector2(-40, -30)
    add_child(label)
    var tween = create_tween()
    tween.set_parallel(true)
    tween.tween_property(label, "position:y", label.position.y - 25, 1.5)
    tween.tween_property(label, "modulate:a", 0.0, 1.5).set_delay(0.5)
    tween.chain().tween_callback(label.queue_free)

## Clean up any spawned reinforcement enemies on mini-boss death
func _cleanup_minions() -> void:
    for minion in spawned_minions:
        if is_instance_valid(minion):
            minion.queue_free()
    spawned_minions.clear()

## Mini-boss death sequence (lighter than full boss)
func _play_mini_boss_death() -> void:
    # Disable collision
    set_collision_layer_value(3, false)
    velocity = Vector2.ZERO
    
    # Flash sequence (3 flashes — shorter than boss's 5)
    for i in range(3):
        if sprite:
            sprite.modulate = Color(2, 2, 2) if i % 2 == 0 else Color(1, 0.5, 0.5)
        EffectsManager.screen_shake(6.0, 0.2)
        await get_tree().create_timer(0.25).timeout
    
    # Burst particles
    _spawn_death_particles()
    
    # Remove
    queue_free()

## Death particles (12 — fewer than boss's 20)
func _spawn_death_particles() -> void:
    for i in range(12):
        var particle = ColorRect.new()
        particle.size = Vector2(5, 5)
        particle.color = Color(0.5, 0.4, 0.6)
        particle.global_position = global_position
        get_parent().add_child(particle)
        
        var angle = randf() * TAU
        var speed = randf_range(40, 120)
        var end_pos = global_position + Vector2(cos(angle), sin(angle)) * speed
        
        var tween = create_tween()
        tween.set_parallel(true)
        tween.tween_property(particle, "global_position", end_pos, 0.5)
        tween.tween_property(particle, "modulate:a", 0.0, 0.5)
        tween.chain().tween_callback(particle.queue_free)
```

**3. Create `characters/enemies/states/mini_boss_idle.gd`:**

Follow the BossIdle pattern but use `player.` (NOT `enemy.`) since regular enemy states use `player.` which maps to the State base class `var player`. The BossIdle uses `enemy.` which is a legacy inconsistency.

**CRITICAL:** The State base class (`state.gd`) defines `var player: CharacterBody2D`. The StateMachine.init() sets `child.player = entity`. So `player` IS the reference to the entity. Boss states use `enemy.` (a legacy pattern). For mini-boss states, use `player.` to match the 10+ regular enemy states (enemy_idle, enemy_chase, enemy_attack, cat_stealth, cat_pounce, rat_swarm_chase, shadow_phase, etc.).

```gdscript
extends State
class_name MiniBossIdle
## Mini-boss idle state - waits briefly, faces target, then picks next attack.
## Uses attack pattern cycling from MiniBossBase.get_next_attack_state().

var idle_timer: float = 0.0
@export var idle_duration: float = 1.5

func enter() -> void:
    idle_timer = 0.0
    player.velocity = Vector2.ZERO

func physics_update(delta: float) -> void:
    if not player.can_act():
        return
    
    # Face target
    if player.target:
        player.update_facing(player.get_direction_to_target())
    
    # No target — go chase
    if not player.target:
        state_machine.transition_to("Chase")
        return
    
    idle_timer += delta
    if idle_timer >= idle_duration:
        # Use get_attack_state_name() for compatibility with existing boss pattern
        if player.has_method("get_attack_state_name"):
            var attack_state = player.get_attack_state_name()
            state_machine.transition_to(attack_state)
        else:
            state_machine.transition_to("Chase")
```

**IMPORTANT NOTES:**
- Use path-based extends: `extends "res://characters/enemies/enemy_base.gd"` for mini_boss_base.gd
- MiniBossIdle uses `player.` not `enemy.` — matching the State base class and all regular enemy states
- `get_attack_state_name()` on MiniBossBase ensures BossIdle pattern compatibility if ever reused
- Death sequence is async (uses await) — same pattern as BossRaccoonKing._play_death_sequence()
- `spawned_minions` array tracks reinforcements for cleanup (Plans 02-04 will push to this)
  </action>
  <verify>
1. Open the project in Godot (or verify with `grep -r "class_name MiniBossBase" characters/`)
2. Verify `characters/enemies/mini_boss_base.gd` exists and has `class_name MiniBossBase`
3. Verify `characters/enemies/states/mini_boss_idle.gd` exists and has `class_name MiniBossIdle`
4. Verify `autoloads/events.gd` contains `signal mini_boss_spawned` and `signal mini_boss_defeated`
5. Verify mini_boss_idle.gd uses `player.` (not `enemy.`)
  </verify>
  <done>
MiniBossBase class exists extending EnemyBase with attack pattern cycling, loot granting, minion cleanup, and death sequence. MiniBossIdle state exists with target tracking and attack state selection. Events.gd has mini_boss_spawned and mini_boss_defeated signals.
  </done>
</task>

<task type="auto">
  <name>Task 2: SaveManager, GameManager, EquipmentDatabase, and BossHealthBar integration</name>
  <files>
    autoloads/save_manager.gd
    autoloads/game_manager.gd
    systems/equipment/equipment_database.gd
    ui/hud/boss_health_bar.gd
  </files>
  <action>
**1. Update `autoloads/save_manager.gd`:**

a) Change SAVE_VERSION from 1 to 2:
```gdscript
const SAVE_VERSION: int = 2
```

b) Add `mini_bosses_defeated` to `_get_default_data()`:
```gdscript
func _get_default_data() -> Dictionary:
    return {
        "version": SAVE_VERSION,
        "level": 1,
        "total_exp": 0,
        "coins": 0,
        "current_zone": "neighborhood",
        "boss_defeated": false,
        "mini_bosses_defeated": {
            "alpha_raccoon": false,
            "crow_matriarch": false,
            "rat_king": false,
        },
        "timestamp": Time.get_unix_time_from_system()
    }
```

c) Add to `_gather_save_data()` (after `data.boss_defeated = GameManager.boss_defeated` around line 75):
```gdscript
data.mini_bosses_defeated = GameManager.mini_bosses_defeated.duplicate()
```

d) Add to `_apply_save_data()` (after `GameManager.boss_defeated = data.get("boss_defeated", false)` around line 92):
```gdscript
# Version migration: add mini_bosses_defeated for v1 saves
GameManager.mini_bosses_defeated = data.get("mini_bosses_defeated", {
    "alpha_raccoon": false,
    "crow_matriarch": false,
    "rat_king": false,
})
```

e) Update `_validate_save_data()` — do NOT add "mini_bosses_defeated" to required_fields (it's optional for v1 compatibility). The `.get()` with defaults in _apply handles missing field gracefully.

**2. Update `autoloads/game_manager.gd`:**

a) Add mini_bosses_defeated dictionary (after `var boss_defeated: bool = false` around line 44):
```gdscript
## Track which mini-bosses have been defeated (one-time per save)
var mini_bosses_defeated: Dictionary = {
    "alpha_raccoon": false,
    "crow_matriarch": false,
    "rat_king": false,
}
```

b) Connect to mini-boss defeat signal in `_ready()` (after `Events.boss_defeated.connect(_on_boss_defeated)` line 54):
```gdscript
Events.mini_boss_defeated.connect(_on_mini_boss_defeated)
```

c) Add auto-save connection in `_ready()` (after the boss_defeated autosave connect around line 59):
```gdscript
# Auto-save after mini-boss defeat
Events.mini_boss_defeated.connect(_on_mini_boss_defeated_autosave)
```

d) Add handler function (after `_on_boss_defeated` function around line 78):
```gdscript
func _on_mini_boss_defeated(_boss: Node, boss_key: String) -> void:
    if mini_bosses_defeated.has(boss_key):
        mini_bosses_defeated[boss_key] = true

func _on_mini_boss_defeated_autosave(_boss: Node, _boss_key: String) -> void:
    # Wait 2 seconds for death animation + loot notification
    await get_tree().create_timer(2.0).timeout
    SaveManager.save_game()
    print("[GameManager] Auto-saved after mini-boss defeat")
```

**3. Update `systems/equipment/equipment_database.gd`:**

Add 3 rare mini-boss equipment items at the END of the EQUIPMENT dictionary (after the `guard_helmet` entry, before the closing `}`):

```gdscript
    # === MINI-BOSS LOOT (RARE) ===
    "raccoon_crown": {
        "id": "raccoon_crown",
        "name": "Raccoon Crown",
        "desc": "Trophy from the Alpha. +15 Max HP, +5 Attack",
        "type": "equipment",
        "slot": Slot.HAT,
        "stats": {StatType.MAX_HEALTH: 15, StatType.ATTACK_DAMAGE: 5},
        "color": Color(1.0, 0.85, 0.2),  # Gold crown
    },
    "crow_feather_coat": {
        "id": "crow_feather_coat",
        "name": "Crow Feather Coat",
        "desc": "Dark plumage of the Matriarch. +10 Speed, +10% Defense",
        "type": "equipment",
        "slot": Slot.COAT,
        "stats": {StatType.MOVE_SPEED: 10, StatType.DEFENSE: 10},
        "color": Color(0.1, 0.08, 0.15),  # Dark purple-black
    },
    "rat_king_collar": {
        "id": "rat_king_collar",
        "name": "Rat King's Collar",
        "desc": "Filthy but powerful. +8 Attack, +5 Guard Regen",
        "type": "equipment",
        "slot": Slot.COLLAR,
        "stats": {StatType.ATTACK_DAMAGE: 8, StatType.GUARD_REGEN: 5},
        "color": Color(0.4, 0.35, 0.2),  # Dirty brown
    },
```

These are meaningfully stronger than shop items (e.g., Raccoon Crown: +15 HP +5 ATK vs Guard Helmet: +10% DEF +5 Guard Regen).

**4. Update `ui/hud/boss_health_bar.gd`:**

Adapt the existing BossHealthBar to also handle mini-boss signals with a smaller bar.

a) Add mini-boss color constant (after existing color constants around line 15):
```gdscript
const FILL_COLOR_MINIBOSS: Color = Color(0.9, 0.6, 0.2)  # Orange for mini-boss
```

b) Add mini-boss tracking state (after `var fill_tween: Tween` around line 35):
```gdscript
var is_mini_boss: bool = false
```

c) Connect mini-boss signals in `_ready()` (after the existing boss signal connections, around line 48):
```gdscript
    # Mini-boss signals
    Events.mini_boss_spawned.connect(_on_mini_boss_spawned)
    Events.mini_boss_defeated.connect(_on_mini_boss_defeated)
```

d) Add mini-boss handler functions (after `_on_boss_defeated` function, before the UPDATES section):
```gdscript
func _on_mini_boss_spawned(boss: Node, boss_name_text: String) -> void:
    boss_ref = boss
    is_mini_boss = true
    is_enraged = false
    
    # Set name
    boss_name_label.text = boss_name_text
    boss_name_label.add_theme_font_size_override("font_size", 11)
    
    # Initialize health
    if boss.health:
        max_health = boss.health.max_health
        current_health = boss.health.current_health
    
    # Set fill color for mini-boss (orange instead of red)
    fill.color = FILL_COLOR_MINIBOSS
    
    # Update fill bar
    fill.size.x = BAR_WIDTH
    
    # Show
    _show_bar()

func _on_mini_boss_defeated(_boss: Node, _boss_key: String) -> void:
    is_mini_boss = false
    
    # Drain bar dramatically (same as boss)
    var tween = create_tween()
    tween.tween_property(fill, "size:x", 0.0, 0.5)
    tween.tween_property(self, "modulate:a", 0.0, 0.3)
    tween.tween_callback(func(): visible = false)
    
    boss_ref = null
```

e) Update `_on_boss_spawned` to reset mini-boss flag (add `is_mini_boss = false` at start of that function):
```gdscript
func _on_boss_spawned(boss: Node) -> void:
    boss_ref = boss
    is_mini_boss = false
    # ... rest unchanged
```

f) Update `_show_damage_flash` to use correct color on flash recovery (the existing line `flash_tween.tween_property(fill, "color", FILL_COLOR_ENRAGED if is_enraged else FILL_COLOR, 0.1)` should also consider mini-boss):
Replace the flash color recovery line with:
```gdscript
    var restore_color = FILL_COLOR_ENRAGED if is_enraged else (FILL_COLOR_MINIBOSS if is_mini_boss else FILL_COLOR)
    flash_tween.tween_property(fill, "color", restore_color, 0.1)
```
  </action>
  <verify>
1. Grep for `mini_bosses_defeated` in save_manager.gd and game_manager.gd — should appear in both
2. Grep for `raccoon_crown` in equipment_database.gd — should find the new item
3. Grep for `mini_boss_spawned` in boss_health_bar.gd — should find the connection
4. Verify SAVE_VERSION is 2 in save_manager.gd
5. Verify `.get("mini_bosses_defeated", {...})` pattern in _apply_save_data (v1 migration)
6. Run the game and verify no startup errors from modified autoloads
  </verify>
  <done>
SaveManager persists mini_bosses_defeated dict with v1→v2 migration. GameManager tracks defeats and auto-saves. EquipmentDatabase has 3 rare mini-boss items (raccoon_crown, crow_feather_coat, rat_king_collar). BossHealthBar responds to mini-boss signals with orange fill color and mid-size font.
  </done>
</task>

</tasks>

<verification>
1. All 7 files modified/created exist and have no syntax errors
2. `Events.mini_boss_spawned` and `Events.mini_boss_defeated` signals exist
3. `MiniBossBase` extends EnemyBase, has attack pattern cycling, loot granting, death sequence
4. `MiniBossIdle` state uses `player.` convention and calls `get_attack_state_name()`
5. SaveManager has `mini_bosses_defeated` in default data, gather, and apply (with v1 migration)
6. GameManager has `mini_bosses_defeated` dict and connects to defeat signal for tracking + autosave
7. EquipmentDatabase has 3 rare items with appropriate stats
8. BossHealthBar connects to `mini_boss_spawned` / `mini_boss_defeated` signals and shows orange bar
9. Game launches without errors from modified autoloads
</verification>

<success_criteria>
- MiniBossBase is a complete, extensible base class that Plans 02-04 can subclass
- All signal wiring works: spawn → health bar shows, defeat → GameManager tracks → SaveManager persists
- Equipment loot items are registered and grantable via EquipmentManager.add_equipment()
- BossHealthBar shows correctly for both existing boss AND new mini-bosses (no conflicts)
- Save version migration handles old v1 saves gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/20-mini-bosses/20-01-SUMMARY.md`
</output>
