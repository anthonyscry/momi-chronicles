---
phase: 09-exp-levelup
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - characters/player/player.gd
  - characters/player/player.tscn
  - autoloads/effects_manager.gd
  - autoloads/audio_manager.gd
autonomous: true

must_haves:
  truths:
    - "Player stats increase on level up"
    - "Level up has visual celebration effect"
    - "Level up has audio feedback"
  artifacts:
    - path: "characters/player/player.gd"
      provides: "Stat scaling integration"
  key_links:
    - from: "player.gd"
      to: "progression_component.gd"
      via: "@onready reference and stat application"
---

<objective>
Integrate progression into player stats and add level up celebration effects.

Purpose: Make leveling feel rewarding and impactful on gameplay
Output: Stats scale with level, flashy level up effect
</objective>

<context>
@characters/player/player.gd (player class)
@characters/player/player.tscn (player scene)
@components/progression/progression_component.gd (from 09-01)
@autoloads/effects_manager.gd (visual effects)
@autoloads/audio_manager.gd (sound)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate Progression into Player</name>
  <files>characters/player/player.gd, characters/player/player.tscn</files>
  <action>
1. Add ProgressionComponent to player.tscn:
   - Add child node under Player root
   - Instance: components/progression/progression_component.tscn

2. In player.gd, add reference and stat scaling:
```gdscript
@onready var progression: ProgressionComponent = $ProgressionComponent

# Base stats (level 1)
const BASE_WALK_SPEED: float = 80.0
const BASE_RUN_SPEED: float = 140.0
const BASE_ATTACK_DAMAGE: int = 25
const BASE_MAX_HEALTH: int = 100

func _ready() -> void:
    add_to_group("player")
    state_machine.init(self)
    
    if hurtbox:
        hurtbox.hurt.connect(_on_hurt)
    if health:
        health.died.connect(_on_died)
    
    # Connect to level up
    if progression:
        progression.level_changed.connect(_on_level_changed)
    
    # Apply initial stats
    _apply_level_stats()

func _on_level_changed(new_level: int) -> void:
    _apply_level_stats()
    _play_level_up_effect()

func _apply_level_stats() -> void:
    if not progression:
        return
    
    # Update speeds
    var speed_bonus = progression.get_stat_bonus("move_speed")
    # Store effective speeds (states read from player)
    
    # Update health
    var health_bonus = progression.get_stat_bonus("max_health")
    if health:
        var new_max = BASE_MAX_HEALTH + health_bonus
        var heal_amount = new_max - health.max_health  # Heal the difference
        health.max_health = new_max
        if heal_amount > 0:
            health.heal(heal_amount)  # Full heal on level up
    
    # Update attack damage
    var damage_bonus = progression.get_stat_bonus("attack_damage")
    if hitbox:
        hitbox.damage = BASE_ATTACK_DAMAGE + damage_bonus
    
    # Emit for UI
    Events.stats_updated.emit("all", progression.get_level())

func get_effective_walk_speed() -> float:
    var bonus = 0
    if progression:
        bonus = progression.get_stat_bonus("move_speed")
    return BASE_WALK_SPEED + bonus

func get_effective_run_speed() -> float:
    var bonus = 0
    if progression:
        bonus = progression.get_stat_bonus("move_speed")
    return BASE_RUN_SPEED + bonus * 1.5  # Run gets bigger bonus

func get_current_level() -> int:
    if progression:
        return progression.get_level()
    return 1

func _play_level_up_effect() -> void:
    # Handled by effects manager via signal
    pass
```

3. Update movement states to use effective speeds:
   - In player_walk.gd: `player.velocity = direction * player.get_effective_walk_speed()`
   - In player_run.gd: `player.velocity = direction * player.get_effective_run_speed()`
  </action>
  <verify>Player scene has ProgressionComponent, stats scale on level up</verify>
  <done>Player stats scale with level</done>
</task>

<task type="auto">
  <name>Task 2: Level Up Visual Effect</name>
  <files>autoloads/effects_manager.gd</files>
  <action>
Add level up celebration effect:

```gdscript
func _ready() -> void:
    # ... existing connections ...
    Events.player_leveled_up.connect(_on_player_level_up)

func _on_player_level_up(new_level: int) -> void:
    var player = get_tree().get_first_node_in_group("player")
    if not player:
        return
    
    # Create level up visual
    _create_level_up_effect(player)
    
    # Screen effects
    screen_shake(8.0, 0.3)
    _flash_screen(Color(1, 0.95, 0.6, 0.4), 0.3)  # Golden flash

func _create_level_up_effect(target: Node2D) -> void:
    # Create expanding ring
    var ring = _create_ring_effect(target.global_position)
    
    # Create floating "LEVEL UP!" text
    var label = Label.new()
    label.text = "LEVEL UP!"
    label.add_theme_font_size_override("font_size", 16)
    label.add_theme_color_override("font_color", Color(1, 0.9, 0.3))
    label.add_theme_color_override("font_outline_color", Color(0.3, 0.2, 0))
    label.add_theme_constant_override("outline_size", 2)
    label.global_position = target.global_position + Vector2(-30, -30)
    label.z_index = 100
    get_tree().current_scene.add_child(label)
    
    # Animate text floating up and fading
    var tween = create_tween()
    tween.set_parallel(true)
    tween.tween_property(label, "global_position:y", label.global_position.y - 40, 1.0)
    tween.tween_property(label, "modulate:a", 0.0, 1.0).set_delay(0.5)
    tween.chain().tween_callback(label.queue_free)

func _create_ring_effect(pos: Vector2) -> void:
    # Simple expanding circle using a ColorRect or custom draw
    # For simplicity, use multiple particles going outward
    for i in range(8):
        var angle = i * TAU / 8
        var particle = ColorRect.new()
        particle.size = Vector2(4, 4)
        particle.color = Color(1, 0.9, 0.4, 1)
        particle.global_position = pos
        particle.z_index = 100
        get_tree().current_scene.add_child(particle)
        
        var end_pos = pos + Vector2(cos(angle), sin(angle)) * 30
        var tween = create_tween()
        tween.set_parallel(true)
        tween.tween_property(particle, "global_position", end_pos, 0.4).set_ease(Tween.EASE_OUT)
        tween.tween_property(particle, "modulate:a", 0.0, 0.4)
        tween.chain().tween_callback(particle.queue_free)

func _flash_screen(color: Color, duration: float) -> void:
    var flash = ColorRect.new()
    flash.color = color
    flash.anchors_preset = Control.PRESET_FULL_RECT
    flash.mouse_filter = Control.MOUSE_FILTER_IGNORE
    flash.z_index = 1000
    
    # Add to CanvasLayer for HUD-level rendering
    var canvas = CanvasLayer.new()
    canvas.layer = 100
    canvas.add_child(flash)
    get_tree().current_scene.add_child(canvas)
    
    var tween = create_tween()
    tween.tween_property(flash, "modulate:a", 0.0, duration)
    tween.tween_callback(canvas.queue_free)
```
  </action>
  <verify>Level up triggers golden flash, expanding ring, floating text</verify>
  <done>Level up visual celebration effect</done>
</task>

<task type="auto">
  <name>Task 3: Level Up Sound Effect</name>
  <files>autoloads/audio_manager.gd</files>
  <action>
1. Add level up sound to AudioManager:

```gdscript
# In the SFX section
var sfx_paths = {
    # ... existing sfx ...
    "level_up": "res://assets/audio/sfx/level_up.wav"
}
```

2. Connect to level up signal:
```gdscript
func _ready() -> void:
    # ... existing connections ...
    Events.player_leveled_up.connect(_on_level_up)

func _on_level_up(_level: int) -> void:
    play_sfx("level_up")
```

3. Create placeholder level_up.wav (if generate_placeholder_audio.py exists):
   - Add a rising chime/arpeggio sound
   - Or manually create simple ascending beeps

For now, we can reuse "victory" sound or create via Python:
```python
# Add to generate_placeholder_audio.py
def generate_level_up():
    # Rising arpeggio - 3 notes ascending
    sample_rate = 44100
    freqs = [440, 554, 659]  # A4, C#5, E5
    samples = []
    for freq in freqs:
        t = np.linspace(0, 0.15, int(sample_rate * 0.15))
        wave = np.sin(2 * np.pi * freq * t) * 0.5
        # Envelope
        env = np.exp(-t * 8)
        samples.extend((wave * env * 32767).astype(np.int16))
    return np.array(samples, dtype=np.int16)
```
  </action>
  <verify>Level up plays a celebratory sound</verify>
  <done>Level up audio feedback</done>
</task>

</tasks>

<verification>
1. Run game
2. Kill enemies until level up (4 raccoons for level 2)
3. Verify:
   - Golden screen flash
   - "LEVEL UP!" text floats up
   - Expanding particle ring
   - Sound plays
   - HP bar shows increased max health
   - Damage numbers increase on next attack
</verification>

<success_criteria>
- Stats visibly increase (test with damage numbers)
- Level up effect is noticeable and satisfying
- Player is healed to new max HP on level up
- No performance issues with effects
</success_criteria>

<output>
After completion, create `.planning/phases/09-exp-levelup/09-02-SUMMARY.md`
</output>
