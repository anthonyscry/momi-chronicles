---
phase: 41-quest-tracking-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autoloads/events.gd
  - autoloads/quest_manager.gd
  - autoloads/save_manager.gd
  - autoloads/game_manager.gd
  - systems/quest/quest_objective.gd
  - systems/quest/quest_data.gd
autonomous: true

must_haves:
  truths:
    - "QuestManager loads sample quests on startup without errors"
    - "Talking to an NPC with an available quest auto-starts it"
    - "Talking to required NPCs completes talk-to objectives"
    - "Entering required zones completes visit objectives"
    - "Quest state persists across save and load"
    - "New game resets all quest progress"
  artifacts:
    - path: "autoloads/quest_manager.gd"
      provides: "Quest lifecycle, event-driven objective completion, sample quest definitions"
    - path: "autoloads/events.gd"
      provides: "Fixed quest_updated signal with 2 params"
    - path: "autoloads/save_manager.gd"
      provides: "Quest data save/load integration"
    - path: "systems/quest/quest_objective.gd"
      provides: "Trigger metadata for event-driven completion"
  key_links:
    - from: "autoloads/quest_manager.gd"
      to: "Events.dialogue_started"
      via: "signal connection in _ready()"
      pattern: "Events\\.dialogue_started\\.connect"
    - from: "autoloads/quest_manager.gd"
      to: "Events.zone_entered"
      via: "signal connection in _ready()"
      pattern: "Events\\.zone_entered\\.connect"
    - from: "autoloads/save_manager.gd"
      to: "QuestManager.get_save_data()"
      via: "_gather_save_data() call"
      pattern: "QuestManager\\.get_save_data"
---

<objective>
Wire the quest backend so quests load on startup, complete automatically via game events, and persist through save/load.

Purpose: The QuestManager autoload, Quest classes, and UI stubs already exist but are disconnected. This plan fixes bugs in existing code and wires everything together so the quest engine actually runs.

Output: A working quest backend with 2 sample quests that auto-trigger from NPC dialogue and zone entry, with full save/load persistence.
</objective>

<context>
@autoloads/events.gd
@autoloads/quest_manager.gd
@autoloads/save_manager.gd
@autoloads/game_manager.gd
@systems/quest/quest.gd
@systems/quest/quest_data.gd
@systems/quest/quest_objective.gd
@characters/npcs/dialogue_npc.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix bugs and extend quest data model</name>
  <files>
    autoloads/events.gd
    autoloads/quest_manager.gd
    systems/quest/quest_objective.gd
    systems/quest/quest_data.gd
  </files>
  <action>
    **Fix Events.quest_updated signal signature (BUG — will crash at connect time):**
    In `autoloads/events.gd`, line 109, change:
    ```
    signal quest_updated(quest_id)
    ```
    to:
    ```
    signal quest_updated(quest_id, objective_index)
    ```
    This matches QuestManager's emit call and the UI handler signatures in quest_tracker.gd and quest_log.gd.

    **Fix print() → DebugLogger in quest_manager.gd (convention violation):**
    Replace ALL `print(` calls with `DebugLogger.log_system(` throughout quest_manager.gd.
    There are ~6 instances (lines ~200, 312, 322, 332, 345, 355 area). Search for `print(` and replace each one.

    **Extend QuestObjective with trigger metadata:**
    In `systems/quest/quest_objective.gd`, add these properties after the existing properties section:
    ```gdscript
    ## What event type triggers completion: "dialogue", "zone", "manual", ""
    var trigger_type: String = ""

    ## The specific ID to match (dialogue_id for "dialogue", zone_name for "zone")
    var trigger_id: String = ""

    ## Target count for counter-based objectives (default 1 = boolean completion)
    var target_count: int = 1

    ## Current progress count
    var current_count: int = 0
    ```

    Update the `_init()` to accept trigger params with defaults:
    ```gdscript
    func _init(
        p_description: String = "",
        p_completed: bool = false,
        p_optional: bool = false,
        p_trigger_type: String = "",
        p_trigger_id: String = "",
        p_target_count: int = 1
    ) -> void:
        description = p_description
        completed = p_completed
        optional = p_optional
        trigger_type = p_trigger_type
        trigger_id = p_trigger_id
        target_count = p_target_count
    ```

    Add an `advance()` method for counter objectives:
    ```gdscript
    ## Advance progress by 1. Returns true if objective just completed.
    func advance() -> bool:
        if completed:
            return false
        current_count += 1
        if current_count >= target_count:
            completed = true
            return true
        return false
    ```

    Update `to_dict()` to include trigger fields:
    ```gdscript
    return {
        "description": description,
        "completed": completed,
        "optional": optional,
        "trigger_type": trigger_type,
        "trigger_id": trigger_id,
        "target_count": target_count,
        "current_count": current_count,
    }
    ```

    Update `from_dict()` to restore trigger fields using `.get()` with defaults (backward compatible):
    ```gdscript
    trigger_type = data.get("trigger_type", "")
    trigger_id = data.get("trigger_id", "")
    target_count = data.get("target_count", 1)
    current_count = data.get("current_count", 0)
    ```

    **Update QuestData.create_quest() to pass trigger data:**
    In `systems/quest/quest_data.gd`, add parallel arrays for trigger data:
    ```gdscript
    @export var objective_trigger_types: Array[String] = []
    @export var objective_trigger_ids: Array[String] = []
    @export var objective_target_counts: Array[int] = []
    ```

    Update `create_quest()` to pass trigger data to QuestObjective:
    ```gdscript
    var trigger_type: String = ""
    var trigger_id: String = ""
    var target_count: int = 1
    if i < objective_trigger_types.size():
        trigger_type = objective_trigger_types[i]
    if i < objective_trigger_ids.size():
        trigger_id = objective_trigger_ids[i]
    if i < objective_target_counts.size():
        target_count = objective_target_counts[i]
    var objective = QuestObjective.new(obj_description, false, is_optional, trigger_type, trigger_id, target_count)
    ```
  </action>
  <verify>
    Open the game briefly (`godot --path .` then close). Check console for no parse errors. Grep quest_manager.gd for `print(` — should find zero bare print calls.
  </verify>
  <done>
    Events.quest_updated has 2 params. QuestObjective has trigger_type/trigger_id/target_count/current_count fields. QuestData passes trigger data. All print() replaced with DebugLogger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire quest system into game loop with sample quests</name>
  <files>
    autoloads/quest_manager.gd
    autoloads/save_manager.gd
    autoloads/game_manager.gd
  </files>
  <action>
    **Create sample quest definitions in QuestManager._ready():**
    Add a `_register_all_quests()` method called from `_ready()`. Define 2 sample quests programmatically (following ItemDatabase/EquipmentDatabase pattern — data defined in code):

    **Quest 1: "Meet the Neighbors"**
    ```gdscript
    var q1 = QuestData.new()
    q1.id = "meet_neighbors"
    q1.title = "Meet the Neighbors"
    q1.description = "Gertrude suggested you introduce yourself to the other neighbors."
    q1.is_main_quest = false
    q1.objective_descriptions = ["Talk to Mailman Maurice", "Talk to the Kids Gang", "Talk to Mr. Henderson"]
    q1.optional_objectives = [false, false, false]
    q1.objective_trigger_types = ["dialogue", "dialogue", "dialogue"]
    q1.objective_trigger_ids = ["maurice", "kids_gang", "henderson"]
    q1.objective_target_counts = [1, 1, 1]
    q1.rewards = {"coins": 50, "exp": 25}
    register_quest_data(q1)
    ```

    **Quest 2: "Community Watch"**
    ```gdscript
    var q2 = QuestData.new()
    q2.id = "community_watch"
    q2.title = "Community Watch"
    q2.description = "Maurice heard about trouble in other areas. Patrol the Backyard and Sewers."
    q2.is_main_quest = false
    q2.prerequisite_quest_ids = ["meet_neighbors"]
    q2.objective_descriptions = ["Visit the Backyard", "Visit the Sewers"]
    q2.optional_objectives = [false, false]
    q2.objective_trigger_types = ["zone", "zone"]
    q2.objective_trigger_ids = ["backyard", "sewers"]
    q2.objective_target_counts = [1, 1]
    q2.rewards = {"coins": 75, "exp": 30}
    register_quest_data(q2)
    ```

    **Wire event listeners for auto-completion in QuestManager._ready():**
    Connect to events AFTER registering quests:
    ```gdscript
    Events.dialogue_started.connect(_on_dialogue_started_for_quests)
    Events.zone_entered.connect(_on_zone_entered_for_quests)
    ```

    **Add dialogue-based quest trigger handler:**
    ```gdscript
    func _on_dialogue_started_for_quests(dialogue) -> void:
        # dialogue is a DialogueResource — extract its dialogue_id from loaded dialogues
        var dialogue_id: String = ""
        if dialogue and dialogue.has_method("get") == false:
            # DialogueResource — find its ID from DialogueManager's loaded data
            for did in DialogueManager._dialogues:
                if DialogueManager._dialogues[did] == dialogue:
                    dialogue_id = did
                    break

        if dialogue_id.is_empty():
            return

        # Check if talking to this NPC should START a quest
        # Gertrude starts "meet_neighbors" quest
        if dialogue_id == "gertrude" and can_start_quest("meet_neighbors"):
            start_quest("meet_neighbors")
            DebugLogger.log_system("Quest auto-started: meet_neighbors (talked to Gertrude)")

        # Maurice starts "community_watch" if prerequisites met
        if dialogue_id == "maurice" and can_start_quest("community_watch"):
            start_quest("community_watch")
            DebugLogger.log_system("Quest auto-started: community_watch (talked to Maurice)")

        # Complete "talk to" objectives for active quests
        _check_dialogue_objectives(dialogue_id)
    ```

    **Add zone-based quest trigger handler:**
    ```gdscript
    func _on_zone_entered_for_quests(zone_name: String) -> void:
        _check_zone_objectives(zone_name)
    ```

    **Add objective checking helpers:**
    ```gdscript
    func _check_dialogue_objectives(dialogue_id: String) -> void:
        for quest_id in active_quests.keys():
            var quest: Quest = active_quests[quest_id]
            for i in range(quest.objectives.size()):
                var obj: QuestObjective = quest.objectives[i]
                if obj.trigger_type == "dialogue" and obj.trigger_id == dialogue_id and not obj.is_completed():
                    if obj.advance():
                        DebugLogger.log_system("Quest objective completed: %s [%d] — %s" % [quest_id, i, obj.description])
                        quest_updated.emit(quest_id, i)
                        Events.quest_updated.emit(quest_id, i)
                        if quest.all_objectives_completed():
                            complete_quest(quest_id)

    func _check_zone_objectives(zone_name: String) -> void:
        for quest_id in active_quests.keys():
            var quest: Quest = active_quests[quest_id]
            for i in range(quest.objectives.size()):
                var obj: QuestObjective = quest.objectives[i]
                if obj.trigger_type == "zone" and obj.trigger_id == zone_name and not obj.is_completed():
                    if obj.advance():
                        DebugLogger.log_system("Quest objective completed: %s [%d] — %s" % [quest_id, i, obj.description])
                        quest_updated.emit(quest_id, i)
                        Events.quest_updated.emit(quest_id, i)
                        if quest.all_objectives_completed():
                            complete_quest(quest_id)
    ```

    Note: The `_check_*` helpers emit BOTH the local signal AND the Events signal. The `complete_quest()` method already handles its own Events emission, so don't double-emit on completion — only emit quest_updated from the helpers, let complete_quest handle quest_completed.

    **Wire SaveManager for quest persistence:**
    In `autoloads/save_manager.gd`, in `_gather_save_data()` (after the tutorial data block, before timestamp):
    ```gdscript
    if QuestManager:
        data["quests"] = QuestManager.get_save_data()
    ```

    In `_apply_save_data()` (after tutorial data restore):
    ```gdscript
    if data.has("quests") and QuestManager:
        QuestManager.load_save_data(data["quests"])
    ```

    **Wire GameManager.reset_game() for quest reset:**
    In `autoloads/game_manager.gd`, in `reset_game()` (before the DebugLogger line at the end):
    ```gdscript
    if QuestManager:
        QuestManager.active_quests.clear()
        QuestManager.completed_quest_ids.clear()
        QuestManager.failed_quest_ids.clear()
        QuestManager.current_active_quest_id = ""
    ```

    **Update QuestManager._ready():**
    ```gdscript
    func _ready() -> void:
        _register_all_quests()
        DebugLogger.log_system("QuestManager initialized with %d quests" % available_quests.size())
    ```
    (Event connections go at the end of _ready(), after quest registration.)
  </action>
  <verify>
    Run the game. Walk to Gertrude, press E to talk. Check debug log for "Quest auto-started: meet_neighbors". Walk to Maurice, press E — check for objective completion log. Save game, reload — verify quest state restored. Start new game — verify quests reset.
  </verify>
  <done>
    QuestManager loads 2 sample quests on startup. Talking to Gertrude starts "Meet the Neighbors". Talking to other NPCs completes objectives. Entering zones completes zone objectives. Quest state saves and loads. New game resets quest state.
  </done>
</task>

</tasks>

<verification>
1. Game launches without errors (no signal signature mismatches)
2. QuestManager reports loaded quest count in debug log
3. Talking to Gertrude auto-starts "Meet the Neighbors" quest
4. Talking to Maurice, Kids Gang, Henderson each complete an objective
5. After all 3 objectives: quest completes, 50 coins + 25 EXP granted
6. After completing "Meet the Neighbors", talking to Maurice starts "Community Watch"
7. Entering Backyard and Sewers zones complete objectives
8. Save/load preserves quest state (active quests, completed objectives)
9. New game resets all quest progress
10. No bare `print()` calls in quest_manager.gd
</verification>

<success_criteria>
- Zero parse errors on launch
- 2 sample quests registered and functional
- Event-driven objective completion working for dialogue and zone triggers
- Quest state persists across save/load cycle
- Quest state resets on new game
</success_criteria>

<output>
After completion, create `docs/phases/41-quest-tracking-ui/41-01-SUMMARY.md`
</output>
