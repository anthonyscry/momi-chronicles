---
phase: 16-ring-menu
plan: 04
type: execute
wave: 3
depends_on: ["16-01", "16-02", "16-03"]
files_modified:
  - systems/companions/companion_manager.gd
  - systems/companions/companion_data.gd
  - components/companion_mechanics/zoomies_component.gd
  - components/companion_mechanics/overheat_component.gd
  - components/companion_mechanics/motivation_component.gd
  - characters/npcs/companion_npc.gd
  - characters/npcs/companion_npc.tscn
  - characters/npcs/cinnamon_npc.tscn
  - characters/npcs/philo_npc.tscn
  - characters/player/player.gd
  - world/zones/neighborhood.tscn
  - world/zones/backyard.tscn
  - ui/ring_menu/ring_menu.gd
  - autoloads/game_manager.gd
autonomous: true

must_haves:
  truths:
    - "Three playable bulldogs: Momi, Cinnamon, Philo"
    - "Companions must be recruited before they can be swapped to"
    - "Cinnamon and Philo exist as NPCs on map for recruitment"
    - "Interact with NPC to trigger recruitment dialogue/cutscene"
    - "Can swap between recruited companions from ring menu"
    - "Momi: Zoomies activates after 3 hits (+50% speed)"
    - "Cinnamon: Overheats in combat (slower but tankier)"
    - "Philo: Lazy until motivated (treats/combat boost stats)"
    - "Companion state persists (HP, heat, motivation)"
  artifacts:
    - path: "systems/companions/companion_data.gd"
      provides: "Bulldog companion definitions with correct palettes"
    - path: "components/companion_mechanics/zoomies_component.gd"
      provides: "Momi's hit-counter speed burst mechanic"
    - path: "components/companion_mechanics/overheat_component.gd"
      provides: "Cinnamon's heat/cooldown tank mechanic"
    - path: "components/companion_mechanics/motivation_component.gd"
      provides: "Philo's lazy/motivated support mechanic"
  key_links:
    - from: "ring_menu.gd"
      to: "companion_manager.gd"
      via: "switch_companion call"
      pattern: "companion_manager\\.switch_to"
    - from: "player.gd"
      to: "mechanic components"
      via: "get_speed_multiplier queries"
      pattern: "zoomies|overheat|motivation"
---

<objective>
Create companion system allowing players to swap between different playable characters.

Purpose: Add variety with multiple playable characters, each with unique abilities
Output: Working companion swap system accessible from ring menu
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-ring-menu/16-01-SUMMARY.md
@characters/player/player.gd
@ui/ring_menu/ring_menu.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Companion Data Definitions</name>
  <files>
    systems/companions/companion_data.gd
  </files>
  <action>
Define the three playable bulldog companions:

```gdscript
extends Node
class_name CompanionData

## Companion definitions - The Bulldog Squad!
## Each companion has unique base stats, appearance, and special mechanic

## Color palettes
const MOMI_BLACK = Color("#1a1a1a")
const MOMI_TAN = Color("#8b6914")
const MOMI_WHITE = Color("#ffffff")

const CINNAMON_BLACK = Color("#1a1a1a")
const CINNAMON_TAN = Color("#c4884a")
const CINNAMON_WHITE = Color("#ffffff")

const PHILO_BLACK = Color("#1a1a1a")
const PHILO_WHITE = Color("#ffffff")

const COMPANIONS: Dictionary = {
    # =========================================================================
    # MOMI - French Bulldog (Protagonist, DPS/All-rounder)
    # =========================================================================
    "momi": {
        "id": "momi",
        "name": "Momi",
        "breed": "French Bulldog",
        "desc": "Alert and determined. The leader with zoomies energy!",
        "type": "companion",
        "scene": "res://characters/player/player.tscn",
        "colors": {
            "primary": MOMI_BLACK,      # Black brindle base
            "secondary": MOMI_TAN,      # Tan streaks
            "accent": MOMI_WHITE,       # White chest shield
        },
        "color": MOMI_TAN,  # Main display color (tan for visibility)
        "stats": {
            "max_health": 100,
            "attack": 25,
            "defense": 10,
            "speed": 85,
            "run_speed": 150,
        },
        "special": "zoomies",
        "special_desc": "After landing 3 hits, gains ZOOMIES: +50% speed for 3 seconds",
        "unlocked": true,  # Always available - protagonist
    },
    
    # =========================================================================
    # CINNAMON - English Bulldog (Tank)
    # =========================================================================
    "cinnamon": {
        "id": "cinnamon",
        "name": "Cinnamon",
        "breed": "English Bulldog",
        "desc": "Stocky and tough. Overheats in long fights!",
        "type": "companion",
        "scene": "res://characters/companions/cinnamon.tscn",
        "colors": {
            "primary": CINNAMON_BLACK,   # Black base
            "secondary": CINNAMON_TAN,   # Tan points (eyebrows, cheeks)
            "accent": CINNAMON_WHITE,    # White blaze and chest
        },
        "color": CINNAMON_TAN,  # Main display color
        "stats": {
            "max_health": 150,
            "attack": 30,
            "defense": 20,
            "speed": 55,
            "run_speed": 90,
        },
        "special": "overheat",
        "special_desc": "Tanky but OVERHEATS in combat. Heat builds when attacking/blocking. High heat = slower, panting. Cool down by staying idle.",
        "mechanic": {
            "heat_per_attack": 8,       # Heat gained per attack
            "heat_per_block": 5,        # Heat gained while blocking
            "heat_decay_rate": 15,      # Heat lost per second when idle
            "overheat_threshold": 80,   # Heat level to start slowing
            "max_heat": 100,
            "overheat_speed_penalty": 0.4,  # 40% slower when overheated
            "overheat_defense_bonus": 0.2,  # 20% more defense when overheated (sweating = slippery?)
        },
        "unlocked": false,
    },
    
    # =========================================================================
    # PHILO - Boston Terrier (Support/Speed)
    # =========================================================================
    "philo": {
        "id": "philo",
        "name": "Philo",
        "breed": "Boston Terrier",
        "desc": "Old and lazy... until properly motivated!",
        "type": "companion",
        "scene": "res://characters/companions/philo.tscn",
        "colors": {
            "primary": PHILO_BLACK,     # Black tuxedo
            "secondary": PHILO_WHITE,   # White markings
            "accent": Color("#808080"), # Gray muzzle (old boy)
        },
        "color": PHILO_WHITE,  # Main display color (tuxedo white)
        "stats": {
            # BASE stats (when lazy)
            "max_health": 80,
            "attack": 15,
            "defense": 8,
            "speed": 50,        # Slow when lazy
            "run_speed": 80,
        },
        "motivated_stats": {
            # MOTIVATED stats (when given treats or in combat)
            "attack": 28,
            "speed": 110,       # Zoomy when motivated!
            "run_speed": 180,
        },
        "special": "lazy_motivated",
        "special_desc": "LAZY by default (slow, weak). Gets MOTIVATED by treats or combat. Motivation decays over time.",
        "mechanic": {
            "motivation_from_treat": 50,    # Motivation gained from treat item
            "motivation_from_hit": 15,      # Motivation gained when hitting enemy
            "motivation_from_damage": 25,   # Motivation gained when taking damage
            "motivation_decay_rate": 8,     # Motivation lost per second
            "motivated_threshold": 40,      # Motivation level to become motivated
            "max_motivation": 100,
        },
        "unlocked": false,
    },
}

static func get_companion(companion_id: String) -> Dictionary:
    if COMPANIONS.has(companion_id):
        return COMPANIONS[companion_id].duplicate(true)
    return {}

static func get_all_companions() -> Array:
    var result = []
    for id in COMPANIONS:
        result.append(COMPANIONS[id].duplicate(true))
    return result

static func get_unlocked_companions() -> Array:
    var result = []
    for id in COMPANIONS:
        if COMPANIONS[id].unlocked:
            result.append(COMPANIONS[id].duplicate(true))
    return result

static func get_companion_mechanic(companion_id: String) -> Dictionary:
    var data = get_companion(companion_id)
    return data.get("mechanic", {})
```
  </action>
  <verify>
CompanionData.get_companion("momi") returns French Bulldog data
CompanionData.get_companion("cinnamon") returns English Bulldog data
CompanionData.get_companion("philo") returns Boston Terrier data
Each companion has correct color palette (black/tan/white)
Each companion has unique mechanic config
Momi is unlocked by default
  </verify>
  <done>Three bulldog companions defined with unique mechanics</done>
</task>

<task type="auto">
  <name>Task 2: Create Recruitable Companion NPCs</name>
  <files>
    characters/npcs/companion_npc.gd
    characters/npcs/companion_npc.tscn
    characters/npcs/cinnamon_npc.tscn
    characters/npcs/philo_npc.tscn
    world/zones/neighborhood.tscn
    world/zones/backyard.tscn
  </files>
  <action>
Create NPC base for recruitable companions:

```gdscript
# characters/npcs/companion_npc.gd
extends CharacterBody2D
class_name CompanionNPC

signal interaction_started(npc: CompanionNPC)
signal recruited(companion_id: String)

@export var companion_id: String = ""  # "cinnamon" or "philo"
@export var npc_name: String = ""
@export var idle_dialogue: Array[String] = []
@export var recruitment_dialogue: Array[String] = []

@onready var sprite: Polygon2D = $Sprite
@onready var interaction_area: Area2D = $InteractionArea
@onready var prompt_label: Label = $PromptLabel

var player_in_range: bool = false
var is_recruited: bool = false

func _ready() -> void:
    add_to_group("npcs")
    add_to_group("interactable")
    
    # Set up visual based on companion data
    var data = CompanionData.get_companion(companion_id)
    if data and sprite:
        sprite.color = data.get("color", Color.WHITE)
    
    # Check if already recruited
    if GameManager.companions and GameManager.companions.is_unlocked(companion_id):
        is_recruited = true
        _on_already_recruited()
    
    interaction_area.body_entered.connect(_on_body_entered)
    interaction_area.body_exited.connect(_on_body_exited)
    
    prompt_label.visible = false

func _unhandled_input(event: InputEvent) -> void:
    if not player_in_range or is_recruited:
        return
    
    # Interact with E or Z
    if event.is_action_pressed("interact") or event.is_action_pressed("attack"):
        _start_interaction()
        get_viewport().set_input_as_handled()

func _on_body_entered(body: Node) -> void:
    if body.is_in_group("player"):
        player_in_range = true
        if not is_recruited:
            prompt_label.text = "Press Z to talk"
            prompt_label.visible = true

func _on_body_exited(body: Node) -> void:
    if body.is_in_group("player"):
        player_in_range = false
        prompt_label.visible = false

func _start_interaction() -> void:
    interaction_started.emit(self)
    
    # Simple recruitment flow (can be expanded with dialogue system later)
    # For now, just recruit on interaction
    _recruit()

func _recruit() -> void:
    is_recruited = true
    
    # Unlock companion
    if GameManager.companions:
        GameManager.companions.unlock_companion(companion_id)
    
    # Visual feedback
    _play_recruitment_effect()
    
    # Emit signal
    recruited.emit(companion_id)
    
    # NPC follows or disappears (for now, just hide)
    _on_recruited()

func _play_recruitment_effect() -> void:
    # Celebration particles
    if has_node("/root/EffectsManager"):
        var data = CompanionData.get_companion(companion_id)
        var color = data.get("color", Color.WHITE)
        for i in 5:
            EffectsManager.spawn_pickup_effect(global_position, color)
    
    AudioManager.play_sfx("companion_recruited")
    
    # Flash and scale animation
    var tween = create_tween()
    tween.tween_property(sprite, "scale", Vector2(1.5, 1.5), 0.2)
    tween.tween_property(sprite, "scale", Vector2(1.0, 1.0), 0.2)

func _on_recruited() -> void:
    # After recruitment, NPC could:
    # 1. Follow player (implement later)
    # 2. Disappear with message
    # 3. Stay but with different dialogue
    
    prompt_label.text = "%s joined the squad!" % npc_name
    prompt_label.visible = true
    
    # Hide after delay
    await get_tree().create_timer(2.0).timeout
    prompt_label.visible = false
    
    # For now, make NPC semi-transparent to show they're recruited
    sprite.modulate.a = 0.5

func _on_already_recruited() -> void:
    # Already recruited, show as ghost/memory or hide
    sprite.modulate.a = 0.3
    prompt_label.text = "(Already in squad)"
```

Create companion_npc.tscn:
```
CompanionNPC (CharacterBody2D)
├── Sprite (Polygon2D, simple dog shape, ~20x16 px)
├── CollisionShape2D (capsule for NPC body)
├── InteractionArea (Area2D)
│   └── CollisionShape2D (circle, radius 24 - interaction range)
└── PromptLabel (Label, positioned above sprite)
```

Create cinnamon_npc.tscn (instance of companion_npc):
- Set companion_id = "cinnamon"
- Set npc_name = "Cinnamon"
- Set sprite color to CINNAMON_TAN
- Make sprite slightly larger/stockier for English Bulldog look

Create philo_npc.tscn (instance of companion_npc):
- Set companion_id = "philo"
- Set npc_name = "Philo"
- Set sprite color to PHILO_WHITE (tuxedo)
- Could add sleeping animation (he's lazy!)

Place NPCs in zones for testing:
- **Cinnamon**: Backyard zone (maybe near the shed, guarding something?)
- **Philo**: Neighborhood zone (sleeping on a porch?)

Add input action if not exists:
- "interact" = E key (or reuse attack/Z)

Add recruitment sound to AudioManager:
```gdscript
"companion_recruited": preload("res://assets/audio/sfx/companion_recruited.wav"),
```
  </action>
  <verify>
NPCs appear in zones at designated positions
Walk up to NPC - prompt appears "Press Z to talk"
Press Z - recruitment triggers, companion unlocked
NPC shows "joined the squad!" message
Companion now appears in ring menu
Already-recruited NPCs show as faded
  </verify>
  <done>Recruitable NPCs for Cinnamon and Philo placed in zones</done>
</task>

<task type="auto">
  <name>Task 3: Create Companion Manager</name>
  <files>
    systems/companions/companion_manager.gd
    autoloads/game_manager.gd
    autoloads/events.gd
  </files>
  <action>
Create companion management system (tracks recruitment and switching):

```gdscript
extends Node
class_name CompanionManager

signal companion_switched(old_id: String, new_id: String)
signal companion_unlocked(companion_id: String)

## Currently active companion ID
var active_companion: String = "momi"

## Unlocked companions
var unlocked: Array[String] = ["momi"]

## Companion state storage (HP, buffs, etc.)
var companion_states: Dictionary = {}

## Reference to current player node
var current_player: Node = null

func _ready() -> void:
    # Initialize Momi's state
    _init_companion_state("momi")

func _init_companion_state(companion_id: String) -> void:
    var data = CompanionData.get_companion(companion_id)
    if data.is_empty():
        return
    
    companion_states[companion_id] = {
        "health": data.stats.max_health,
        "max_health": data.stats.max_health,
        "buffs": [],
        # Companion-specific state
        "heat": 0.0,           # Cinnamon's overheat meter
        "motivation": 0.0,     # Philo's motivation meter
        "zoomies_hits": 0,     # Momi's hit counter for zoomies
        "zoomies_active": false,
    }

# =============================================================================
# UNLOCKING
# =============================================================================

func unlock_companion(companion_id: String) -> void:
    if companion_id in unlocked:
        return
    
    var data = CompanionData.get_companion(companion_id)
    if data.is_empty():
        return
    
    unlocked.append(companion_id)
    _init_companion_state(companion_id)
    
    companion_unlocked.emit(companion_id)
    Events.companion_unlocked.emit(companion_id)

func is_unlocked(companion_id: String) -> bool:
    return companion_id in unlocked

func get_unlocked_companions() -> Array[Dictionary]:
    var result: Array[Dictionary] = []
    for id in unlocked:
        var data = CompanionData.get_companion(id)
        if not data.is_empty():
            data["active"] = (id == active_companion)
            data["state"] = companion_states.get(id, {})
            result.append(data)
    return result

# =============================================================================
# SWITCHING
# =============================================================================

func switch_to(companion_id: String) -> bool:
    if companion_id == active_companion:
        return false
    
    if companion_id not in unlocked:
        return false
    
    var data = CompanionData.get_companion(companion_id)
    if data.is_empty():
        return false
    
    # Save current companion state
    _save_current_state()
    
    var old_id = active_companion
    active_companion = companion_id
    
    # Perform the actual swap
    _perform_swap(data)
    
    companion_switched.emit(old_id, companion_id)
    Events.companion_switched.emit(old_id, companion_id)
    
    AudioManager.play_sfx("companion_swap")
    return true

func _save_current_state() -> void:
    if current_player == null:
        return
    
    var state = companion_states.get(active_companion, {})
    
    # Save health
    if current_player.health:
        state["health"] = current_player.health.current_health
        state["max_health"] = current_player.health.max_health
    
    # Save position (for follower logic later)
    state["position"] = current_player.global_position
    
    companion_states[active_companion] = state

func _perform_swap(new_companion_data: Dictionary) -> void:
    if current_player == null:
        current_player = get_tree().get_first_node_in_group("player")
    
    if current_player == null:
        push_error("No player found for companion swap!")
        return
    
    var swap_position = current_player.global_position
    var swap_facing = current_player.facing_direction
    
    # Visual effect at swap point
    _spawn_swap_effect(swap_position)
    
    # For now, just update the current player's stats
    # (Full scene swap would require more complex implementation)
    _apply_companion_stats(new_companion_data)
    
    # Restore saved state if any
    var saved_state = companion_states.get(new_companion_data.id, {})
    if saved_state.has("health") and current_player.health:
        current_player.health.current_health = saved_state.health

func _apply_companion_stats(data: Dictionary) -> void:
    if current_player == null:
        return
    
    var stats = data.get("stats", {})
    
    # Update base stats
    if current_player.has_method("set_base_stats"):
        current_player.set_base_stats(
            stats.get("max_health", 100),
            stats.get("attack", 25),
            stats.get("speed", 80),
            stats.get("run_speed", 140)
        )
    
    # Update color to represent companion
    if current_player.sprite:
        current_player.sprite.color = data.get("color", Color.WHITE)
    
    # Apply special ability modifier
    _apply_special_ability(data.get("special", ""))

func _apply_special_ability(special: String) -> void:
    # Store active special for other systems to query
    current_player.set_meta("companion_special", special)

func _spawn_swap_effect(position: Vector2) -> void:
    if has_node("/root/EffectsManager"):
        # Spawn a burst of particles in companion color
        var data = CompanionData.get_companion(active_companion)
        var color = data.get("color", Color.WHITE)
        get_node("/root/EffectsManager").spawn_pickup_effect(position, color)
        get_node("/root/EffectsManager").spawn_pickup_effect(position, color)

# =============================================================================
# QUERIES
# =============================================================================

func get_active_companion() -> Dictionary:
    return CompanionData.get_companion(active_companion)

func get_active_special() -> String:
    var data = get_active_companion()
    return data.get("special", "")

func has_special(special_name: String) -> bool:
    return get_active_special() == special_name
```

Add to GameManager:
```gdscript
var companions: CompanionManager = null

func _ready() -> void:
    # ... existing ...
    companions = CompanionManager.new()
    add_child(companions)
```

Add signals to Events:
```gdscript
signal companion_switched(old_id: String, new_id: String)
signal companion_unlocked(companion_id: String)
```
  </action>
  <verify>
GameManager.companions exists
switch_to changes active companion
Companion stats applied to player
State saved/restored on swap
  </verify>
  <done>Companion manager handles switching and state</done>
</task>

<task type="auto">
  <name>Task 4: Integrate with Ring Menu and Add Player Support</name>
  <files>
    ui/ring_menu/ring_menu.gd
    characters/player/player.gd
  </files>
  <action>
Update Ring Menu to show and switch companions:

```gdscript
# In ring_menu.gd

func _refresh_ring() -> void:
    match current_ring:
        RingType.ITEMS:
            rings[RingType.ITEMS] = _get_inventory_items()
        RingType.EQUIPMENT:
            rings[RingType.EQUIPMENT] = _get_equipment_items()
        RingType.COMPANIONS:
            rings[RingType.COMPANIONS] = _get_companion_items()
    
    # ... rest of refresh ...

func _get_companion_items() -> Array:
    if not GameManager.companions:
        return []
    return GameManager.companions.get_unlocked_companions()

func _switch_companion(item: Dictionary) -> void:
    var companion_id = item.get("id", "")
    if companion_id.is_empty():
        return
    
    if item.get("active", false):
        # Already active
        AudioManager.play_sfx("menu_error")
        return
    
    if GameManager.companions.switch_to(companion_id):
        # Successfully switched
        _refresh_ring()
        _update_selection()
        
        # Close menu after swap
        await get_tree().create_timer(0.3).timeout
        close_menu()
    else:
        AudioManager.play_sfx("menu_error")
```

Update Player to support companion stat changes:

```gdscript
# Add to player.gd

## Companion base stat overrides
var companion_max_health: int = 100
var companion_attack: int = 25
var companion_walk_speed: float = 80.0
var companion_run_speed: float = 140.0

## Set base stats from companion data
func set_base_stats(max_hp: int, attack: int, walk: float, run: float) -> void:
    companion_max_health = max_hp
    companion_attack = attack
    companion_walk_speed = walk
    companion_run_speed = run
    
    # Re-apply all stats
    _apply_level_stats()

## Update _apply_level_stats to use companion base
func _apply_level_stats() -> void:
    var base_hp = companion_max_health  # Use companion base instead of const
    var base_atk = companion_attack
    
    # Level bonuses
    var level_hp_bonus = 0
    var level_atk_bonus = 0
    if progression:
        level_hp_bonus = progression.get_stat_bonus("max_health")
        level_atk_bonus = progression.get_stat_bonus("attack_damage")
    
    # Equipment bonuses
    var equip_hp_bonus = get_equipment_bonus(EquipmentDatabase.StatType.MAX_HEALTH)
    var equip_atk_bonus = get_equipment_bonus(EquipmentDatabase.StatType.ATTACK)
    
    # Apply health
    if health:
        var new_max = base_hp + level_hp_bonus + equip_hp_bonus
        health.max_health = new_max
        health.current_health = min(health.current_health, new_max)
        Events.player_health_changed.emit(health.current_health, health.max_health)
    
    # Apply attack
    if hitbox:
        hitbox.damage = base_atk + level_atk_bonus + equip_atk_bonus
    
    Events.stats_updated.emit("all", get_current_level())

## Update speed methods to use companion base
func get_effective_walk_speed() -> float:
    var level_bonus = 0
    if progression:
        level_bonus = progression.get_stat_bonus("move_speed")
    var equip_bonus = get_equipment_bonus(EquipmentDatabase.StatType.SPEED)
    return companion_walk_speed + level_bonus + equip_bonus

func get_effective_run_speed() -> float:
    var level_bonus = 0
    if progression:
        level_bonus = progression.get_stat_bonus("move_speed")
    var equip_bonus = get_equipment_bonus(EquipmentDatabase.StatType.SPEED)
    return companion_run_speed + (level_bonus + equip_bonus) * 1.5

## Check if player has a specific companion special ability
func has_companion_special(special_name: String) -> bool:
    return get_meta("companion_special", "") == special_name
```

Create companion mechanic components to handle unique abilities:

```gdscript
# =============================================================================
# components/companion_mechanics/zoomies_component.gd (Momi)
# =============================================================================
extends Node
class_name ZoomiesComponent

signal zoomies_activated
signal zoomies_ended

const HITS_REQUIRED: int = 3
const ZOOMIES_DURATION: float = 3.0
const SPEED_BONUS: float = 0.5  # +50% speed

var hit_count: int = 0
var is_active: bool = false
var timer: float = 0.0

func _process(delta: float) -> void:
    if is_active:
        timer -= delta
        if timer <= 0:
            _end_zoomies()

func on_hit_landed() -> void:
    if is_active:
        return  # Already zooming
    
    hit_count += 1
    if hit_count >= HITS_REQUIRED:
        _activate_zoomies()

func _activate_zoomies() -> void:
    is_active = true
    timer = ZOOMIES_DURATION
    hit_count = 0
    zoomies_activated.emit()
    # Visual: player gets excited, maybe shakes/vibrates

func _end_zoomies() -> void:
    is_active = false
    zoomies_ended.emit()

func get_speed_multiplier() -> float:
    return 1.0 + SPEED_BONUS if is_active else 1.0


# =============================================================================
# components/companion_mechanics/overheat_component.gd (Cinnamon)
# =============================================================================
extends Node
class_name OverheatComponent

signal heat_changed(current: float, max_heat: float)
signal overheated
signal cooled_down

@export var max_heat: float = 100.0
@export var overheat_threshold: float = 80.0
@export var heat_decay_rate: float = 15.0
@export var overheat_speed_penalty: float = 0.4
@export var overheat_defense_bonus: float = 0.2

var current_heat: float = 0.0
var is_overheated: bool = false
var is_idle: bool = true  # Only cool down when idle

func _process(delta: float) -> void:
    # Cool down when idle
    if is_idle and current_heat > 0:
        add_heat(-heat_decay_rate * delta)
    
    # Check overheat state
    var was_overheated = is_overheated
    is_overheated = current_heat >= overheat_threshold
    
    if is_overheated and not was_overheated:
        overheated.emit()
        # Visual: start panting animation, drool particles
    elif not is_overheated and was_overheated:
        cooled_down.emit()

func add_heat(amount: float) -> void:
    current_heat = clamp(current_heat + amount, 0, max_heat)
    heat_changed.emit(current_heat, max_heat)

func on_attack() -> void:
    is_idle = false
    add_heat(8.0)

func on_block() -> void:
    is_idle = false
    add_heat(5.0)

func on_idle() -> void:
    is_idle = true

func get_speed_multiplier() -> float:
    return 1.0 - overheat_speed_penalty if is_overheated else 1.0

func get_defense_multiplier() -> float:
    return 1.0 + overheat_defense_bonus if is_overheated else 1.0


# =============================================================================
# components/companion_mechanics/motivation_component.gd (Philo)
# =============================================================================
extends Node
class_name MotivationComponent

signal motivation_changed(current: float, max_motivation: float)
signal became_motivated
signal became_lazy

@export var max_motivation: float = 100.0
@export var motivated_threshold: float = 40.0
@export var decay_rate: float = 8.0

var current_motivation: float = 0.0
var is_motivated: bool = false

# Stat differences between lazy and motivated
var lazy_stats: Dictionary = {}
var motivated_stats: Dictionary = {}

func _process(delta: float) -> void:
    # Motivation decays over time
    if current_motivation > 0:
        add_motivation(-decay_rate * delta)
    
    # Check motivation state
    var was_motivated = is_motivated
    is_motivated = current_motivation >= motivated_threshold
    
    if is_motivated and not was_motivated:
        became_motivated.emit()
        # Visual: eyes widen, ears perk up, excited!
    elif not is_motivated and was_motivated:
        became_lazy.emit()
        # Visual: yawn, droop, sleepy...

func add_motivation(amount: float) -> void:
    current_motivation = clamp(current_motivation + amount, 0, max_motivation)
    motivation_changed.emit(current_motivation, max_motivation)

func on_treat_used() -> void:
    add_motivation(50.0)
    # Visual: happy food animation!

func on_hit_enemy() -> void:
    add_motivation(15.0)

func on_take_damage() -> void:
    add_motivation(25.0)  # Pain wakes him up!

func get_effective_attack() -> int:
    if is_motivated:
        return motivated_stats.get("attack", 28)
    return lazy_stats.get("attack", 15)

func get_speed_multiplier() -> float:
    if is_motivated:
        return motivated_stats.get("speed", 110) / lazy_stats.get("speed", 50)
    return 1.0
```

Update player.gd to use companion mechanics:

```gdscript
# Add companion mechanic node references
var zoomies: ZoomiesComponent = null
var overheat: OverheatComponent = null
var motivation: MotivationComponent = null

func _setup_companion_mechanic(companion_id: String) -> void:
    # Remove old mechanic components
    if zoomies: zoomies.queue_free()
    if overheat: overheat.queue_free()
    if motivation: motivation.queue_free()
    zoomies = null
    overheat = null
    motivation = null
    
    # Add new one based on companion
    match companion_id:
        "momi":
            zoomies = ZoomiesComponent.new()
            add_child(zoomies)
            zoomies.zoomies_activated.connect(_on_zoomies_activated)
        "cinnamon":
            overheat = OverheatComponent.new()
            add_child(overheat)
            overheat.overheated.connect(_on_overheated)
        "philo":
            motivation = MotivationComponent.new()
            add_child(motivation)
            var data = CompanionData.get_companion("philo")
            motivation.lazy_stats = data.stats
            motivation.motivated_stats = data.motivated_stats
            motivation.became_motivated.connect(_on_philo_motivated)

func get_effective_walk_speed() -> float:
    var base = companion_walk_speed
    # Apply companion mechanic modifiers
    if zoomies and zoomies.is_active:
        base *= zoomies.get_speed_multiplier()
    if overheat and overheat.is_overheated:
        base *= overheat.get_speed_multiplier()
    if motivation:
        base *= motivation.get_speed_multiplier()
    # Level and equipment bonuses...
    return base + level_bonus + equip_bonus
```
  </action>
  <verify>
Ring menu Companions ring shows unlocked companions
Active companion marked in ring
Switching changes player stats and color
Companion specials affect gameplay
Menu closes after successful swap
  </verify>
  <done>Companions integrated with ring menu and combat systems</done>
</task>

</tasks>

<verification>
**Recruitment Testing:**
1. Start game - playing as Momi (only companion unlocked)
2. Go to Neighborhood - find Philo sleeping on a porch
3. Walk up to Philo - "Press Z to talk" prompt appears
4. Press Z - Philo joins! Celebration effect, "Philo joined the squad!"
5. Go to Backyard - find Cinnamon near the shed
6. Walk up to Cinnamon - "Press Z to talk" prompt
7. Press Z - Cinnamon joins! Now have all 3 companions

**Ring Menu Testing:**
8. Open ring menu (Tab), go to Companions ring
9. See all 3 bulldogs with their colors
10. Switch to Cinnamon - player becomes tankier
11. Switch to Philo - player becomes lazy (slow)

**Mechanic Testing:**
12. As Momi: Land 3 hits - ZOOMIES activates (+50% speed for 3s)
13. As Cinnamon: Attack repeatedly - OVERHEATS (slower but +20% defense)
14. As Cinnamon: Stop and wait - cools down, returns to normal
15. As Philo: Start lazy, take damage - becomes MOTIVATED (fast!)
16. As Philo: Wait without action - motivation decays, becomes lazy again

**State Persistence:**
17. Take damage as Cinnamon, switch to Momi
18. Switch back to Cinnamon - HP preserved, heat reset
</verification>

<success_criteria>
COMPANIONS:
- 3 companions: Momi (French Bulldog), Cinnamon (English Bulldog), Philo (Boston Terrier)
- Momi unlocked by default as protagonist
- Correct color palettes (black/tan/white variations)

RECRUITMENT SYSTEM:
- Cinnamon NPC placed in Backyard zone
- Philo NPC placed in Neighborhood zone
- Walk up to NPC shows interaction prompt
- Pressing Z/interact recruits companion
- Recruitment plays celebration effect and sound
- Recruited NPCs show as faded (already in squad)
- Cannot re-recruit already unlocked companions

RING MENU:
- Only recruited companions appear in Companions ring
- Switching changes player stats immediately
- Visual changes reflect companion appearance
- HP and mechanic state persists per companion

MOMI MECHANIC - Zoomies:
- Hit counter tracks attacks landed
- After 3 hits, ZOOMIES activates
- +50% speed for 3 seconds
- Visual feedback (excited animation)

CINNAMON MECHANIC - Overheat:
- Heat builds when attacking/blocking
- Overheats at 80+ heat
- When overheated: 40% slower, 20% more defense
- Cools down when idle
- Visual: panting, drooling

PHILO MECHANIC - Lazy/Motivated:
- Starts lazy (50 speed, 15 attack)
- Motivation from: treats (+50), hits (+15), damage taken (+25)
- Motivated at 40+: becomes fast (110 speed, 28 attack)
- Motivation decays at 8/sec
- Visual: perks up when motivated, droops when lazy
</success_criteria>

<output>
After completion, create `.planning/phases/16-ring-menu/16-04-SUMMARY.md`
</output>
