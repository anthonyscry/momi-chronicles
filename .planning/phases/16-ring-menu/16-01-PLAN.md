---
phase: 16-ring-menu
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/ring_menu/ring_menu.gd
  - ui/ring_menu/ring_menu.tscn
  - ui/ring_menu/ring_item.gd
  - ui/ring_menu/ring_item.tscn
  - autoloads/events.gd
  - project.godot
autonomous: true

must_haves:
  truths:
    - "Ring menu opens with Tab key"
    - "Game pauses when ring menu opens"
    - "Icons arranged in circle around center"
    - "Left/Right rotates selection smoothly"
    - "Up/Down switches between rings"
    - "Menu closes with Tab or Cancel"
    - "Selected item highlighted with glow/scale"
  artifacts:
    - path: "ui/ring_menu/ring_menu.gd"
      provides: "Ring menu controller"
      exports: ["RingMenu"]
    - path: "ui/ring_menu/ring_item.gd"
      provides: "Individual ring item display"
  key_links:
    - from: "ring_menu.gd"
      to: "game_manager.gd"
      via: "pause_game on open"
      pattern: "GameManager\\.pause_game"
    - from: "ring_menu.gd"
      to: "events.gd"
      via: "ring_menu signals"
      pattern: "ring_menu_opened|ring_item_selected"
---

<objective>
Create the core ring menu UI system inspired by Secret of Mana.

Purpose: Intuitive radial menu for quick access to items, equipment, and options during gameplay
Output: Fully functional ring menu with smooth animations and multiple ring support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@ui/menus/pause_menu.gd
@autoloads/game_manager.gd
@autoloads/events.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RingItem component</name>
  <files>
    ui/ring_menu/ring_item.gd
    ui/ring_menu/ring_item.tscn
  </files>
  <action>
Create the individual item display for ring menu slots:

```gdscript
extends Control
class_name RingItem

## Emitted when this item is selected/confirmed
signal item_activated(item_data: Dictionary)

## The data for this ring item
var item_data: Dictionary = {}

## Visual state
var is_selected: bool = false
var target_scale: float = 1.0
var target_alpha: float = 1.0

## Node references
@onready var icon: TextureRect = $Icon
@onready var label: Label = $Label
@onready var glow: ColorRect = $Glow
@onready var quantity_label: Label = $QuantityLabel

const SELECTED_SCALE: float = 1.4
const UNSELECTED_SCALE: float = 0.9
const SELECTED_ALPHA: float = 1.0
const UNSELECTED_ALPHA: float = 0.6
const LERP_SPEED: float = 12.0

func _ready() -> void:
    # Start with glow hidden
    if glow:
        glow.visible = false

func _process(delta: float) -> void:
    # Smooth scale transition
    scale = scale.lerp(Vector2.ONE * target_scale, LERP_SPEED * delta)
    modulate.a = lerp(modulate.a, target_alpha, LERP_SPEED * delta)

## Set up the item display
func setup(data: Dictionary) -> void:
    item_data = data
    
    # Set icon (texture or colored placeholder)
    if data.has("icon") and data.icon:
        icon.texture = data.icon
        icon.visible = true
    else:
        # Use colored placeholder based on type
        icon.visible = false
        var color = _get_type_color(data.get("type", "item"))
        if glow:
            glow.color = color
            glow.visible = true
    
    # Set label
    if label and data.has("name"):
        label.text = data.name
    
    # Set quantity (for stackable items)
    if quantity_label:
        var qty = data.get("quantity", 1)
        quantity_label.visible = qty > 1
        quantity_label.text = "x%d" % qty

func _get_type_color(type: String) -> Color:
    match type:
        "item": return Color(0.4, 0.8, 0.4)      # Green for items
        "equipment": return Color(0.4, 0.6, 1.0) # Blue for equipment
        "companion": return Color(1.0, 0.7, 0.3) # Orange for companions
        "option": return Color(0.7, 0.7, 0.7)    # Gray for options
        _: return Color.WHITE

## Set selected state with animation
func set_selected(selected: bool) -> void:
    is_selected = selected
    target_scale = SELECTED_SCALE if selected else UNSELECTED_SCALE
    target_alpha = SELECTED_ALPHA if selected else UNSELECTED_ALPHA
    
    # Show glow when selected
    if glow:
        glow.visible = selected
    
    # Bring to front when selected
    if selected:
        z_index = 10
    else:
        z_index = 0

## Activate/use this item
func activate() -> void:
    item_activated.emit(item_data)
```

ring_item.tscn structure:
```
RingItem (Control, 64x64)
├── Glow (ColorRect, 72x72, centered, light color with alpha)
├── Icon (TextureRect, 48x48, centered)
├── Label (Label, below icon, small font, centered)
└── QuantityLabel (Label, top-right corner, small)
```

Use simple Polygon2D shapes if no textures:
- Circle for items (green)
- Diamond for equipment (blue)
- Star for companions (orange)
  </action>
  <verify>
Files exist in ui/ring_menu/
RingItem can be instanced and displays placeholder
set_selected animates scale/alpha smoothly
  </verify>
  <done>RingItem component displays items with selection animation</done>
</task>

<task type="auto">
  <name>Task 2: Create RingMenu core</name>
  <files>
    ui/ring_menu/ring_menu.gd
    ui/ring_menu/ring_menu.tscn
    autoloads/events.gd
    project.godot
  </files>
  <action>
Create the main ring menu controller:

```gdscript
extends CanvasLayer
class_name RingMenu

## Ring configuration
const RING_RADIUS: float = 80.0          # Distance from center to items
const ROTATION_SPEED: float = 8.0        # Animation speed
const MAX_VISIBLE_ITEMS: int = 8         # Items visible at once

## Ring types
enum RingType { ITEMS, EQUIPMENT, COMPANIONS, OPTIONS }

## Current state
var is_open: bool = false
var current_ring: RingType = RingType.ITEMS
var selected_index: int = 0
var target_rotation: float = 0.0
var current_rotation: float = 0.0

## Ring data (populated by game systems)
var rings: Dictionary = {
    RingType.ITEMS: [],
    RingType.EQUIPMENT: [],
    RingType.COMPANIONS: [],
    RingType.OPTIONS: []
}

## Ring display names
var ring_names: Dictionary = {
    RingType.ITEMS: "Items",
    RingType.EQUIPMENT: "Equipment",
    RingType.COMPANIONS: "Companions",
    RingType.OPTIONS: "Options"
}

## Node references
@onready var container: Control = $Container
@onready var center_icon: Control = $Container/CenterIcon
@onready var ring_label: Label = $Container/RingLabel
@onready var item_name_label: Label = $Container/ItemNameLabel
@onready var item_desc_label: Label = $Container/ItemDescLabel

## Pooled ring items
var ring_items: Array[RingItem] = []
var RingItemScene: PackedScene = preload("res://ui/ring_menu/ring_item.tscn")

func _ready() -> void:
    process_mode = Node.PROCESS_MODE_ALWAYS
    visible = false
    
    # Pre-create ring item instances
    for i in MAX_VISIBLE_ITEMS:
        var item = RingItemScene.instantiate()
        container.add_child(item)
        ring_items.append(item)
        item.visible = false
    
    # Set up default options ring
    _setup_default_options()

func _setup_default_options() -> void:
    rings[RingType.OPTIONS] = [
        {"id": "save", "name": "Save Game", "type": "option", "desc": "Save your progress"},
        {"id": "settings", "name": "Settings", "type": "option", "desc": "Audio and display options"},
        {"id": "quit", "name": "Quit", "type": "option", "desc": "Return to title screen"},
    ]

func _unhandled_input(event: InputEvent) -> void:
    # Tab to toggle menu
    if event.is_action_pressed("ring_menu"):
        if is_open:
            close_menu()
        else:
            open_menu()
        get_viewport().set_input_as_handled()
        return
    
    if not is_open:
        return
    
    # Navigation when open
    if event.is_action_pressed("ui_left") or event.is_action_pressed("move_left"):
        rotate_selection(-1)
        get_viewport().set_input_as_handled()
    elif event.is_action_pressed("ui_right") or event.is_action_pressed("move_right"):
        rotate_selection(1)
        get_viewport().set_input_as_handled()
    elif event.is_action_pressed("ui_up") or event.is_action_pressed("move_up"):
        switch_ring(-1)
        get_viewport().set_input_as_handled()
    elif event.is_action_pressed("ui_down") or event.is_action_pressed("move_down"):
        switch_ring(1)
        get_viewport().set_input_as_handled()
    elif event.is_action_pressed("ui_accept") or event.is_action_pressed("attack"):
        activate_selected()
        get_viewport().set_input_as_handled()
    elif event.is_action_pressed("ui_cancel") or event.is_action_pressed("dodge"):
        close_menu()
        get_viewport().set_input_as_handled()

func _process(delta: float) -> void:
    if not is_open:
        return
    
    # Smooth rotation animation
    current_rotation = lerp_angle(current_rotation, target_rotation, ROTATION_SPEED * delta)
    _update_item_positions()

# =============================================================================
# MENU CONTROL
# =============================================================================

func open_menu() -> void:
    if is_open:
        return
    
    is_open = true
    visible = true
    
    # Pause game
    GameManager.pause_game()
    
    # Reset selection
    selected_index = 0
    current_rotation = 0.0
    target_rotation = 0.0
    
    # Populate current ring
    _refresh_ring()
    
    # Play sound
    AudioManager.play_sfx("menu_open")
    
    Events.ring_menu_opened.emit()

func close_menu() -> void:
    if not is_open:
        return
    
    is_open = false
    visible = false
    
    # Resume game
    GameManager.resume_game()
    
    # Play sound
    AudioManager.play_sfx("menu_close")
    
    Events.ring_menu_closed.emit()

# =============================================================================
# NAVIGATION
# =============================================================================

func rotate_selection(direction: int) -> void:
    var items = rings[current_ring]
    if items.is_empty():
        return
    
    selected_index = (selected_index + direction) % items.size()
    if selected_index < 0:
        selected_index = items.size() - 1
    
    # Calculate rotation angle
    var angle_per_item = TAU / min(items.size(), MAX_VISIBLE_ITEMS)
    target_rotation = -selected_index * angle_per_item
    
    _update_selection()
    AudioManager.play_sfx("menu_navigate")

func switch_ring(direction: int) -> void:
    var ring_count = RingType.size()
    var current_int = current_ring as int
    current_int = (current_int + direction) % ring_count
    if current_int < 0:
        current_int = ring_count - 1
    current_ring = current_int as RingType
    
    # Reset selection for new ring
    selected_index = 0
    current_rotation = 0.0
    target_rotation = 0.0
    
    _refresh_ring()
    AudioManager.play_sfx("menu_switch")

func activate_selected() -> void:
    var items = rings[current_ring]
    if items.is_empty() or selected_index >= items.size():
        return
    
    var item = items[selected_index]
    
    AudioManager.play_sfx("menu_select")
    Events.ring_item_selected.emit(current_ring, item)
    
    # Handle based on type
    match current_ring:
        RingType.ITEMS:
            _use_item(item)
        RingType.EQUIPMENT:
            _equip_item(item)
        RingType.COMPANIONS:
            _switch_companion(item)
        RingType.OPTIONS:
            _handle_option(item)

# =============================================================================
# RING DISPLAY
# =============================================================================

func _refresh_ring() -> void:
    var items = rings[current_ring]
    
    # Update ring label
    if ring_label:
        ring_label.text = ring_names[current_ring]
    
    # Hide all items first
    for ring_item in ring_items:
        ring_item.visible = false
    
    # Show items for current ring
    var visible_count = min(items.size(), MAX_VISIBLE_ITEMS)
    for i in visible_count:
        ring_items[i].visible = true
        ring_items[i].setup(items[i])
    
    _update_selection()
    _update_item_positions()

func _update_item_positions() -> void:
    var items = rings[current_ring]
    var visible_count = min(items.size(), MAX_VISIBLE_ITEMS)
    
    if visible_count == 0:
        return
    
    var angle_per_item = TAU / visible_count
    var center = container.size / 2
    
    for i in visible_count:
        var angle = current_rotation + (i * angle_per_item) - PI/2  # Start from top
        var pos = center + Vector2(cos(angle), sin(angle)) * RING_RADIUS
        ring_items[i].position = pos - ring_items[i].size / 2

func _update_selection() -> void:
    var items = rings[current_ring]
    
    # Update selected state on all items
    for i in ring_items.size():
        ring_items[i].set_selected(i == selected_index)
    
    # Update center display
    if selected_index < items.size():
        var item = items[selected_index]
        if item_name_label:
            item_name_label.text = item.get("name", "???")
        if item_desc_label:
            item_desc_label.text = item.get("desc", "")

# =============================================================================
# ITEM ACTIONS (Stubs - implemented in later plans)
# =============================================================================

func _use_item(item: Dictionary) -> void:
    # Implemented in 16-02
    print("[RingMenu] Use item: %s" % item.get("name", "unknown"))

func _equip_item(item: Dictionary) -> void:
    # Implemented in 16-03
    print("[RingMenu] Equip: %s" % item.get("name", "unknown"))

func _switch_companion(item: Dictionary) -> void:
    # Implemented in 16-04
    print("[RingMenu] Switch to: %s" % item.get("name", "unknown"))

func _handle_option(item: Dictionary) -> void:
    match item.get("id"):
        "save":
            # Trigger save (implemented in Phase 14)
            print("[RingMenu] Save game")
            if has_node("/root/SaveManager"):
                get_node("/root/SaveManager").save_game()
        "settings":
            # Could open settings submenu
            print("[RingMenu] Settings")
        "quit":
            close_menu()
            get_tree().change_scene_to_file("res://ui/menus/title_screen.tscn")

# =============================================================================
# PUBLIC API (for other systems to populate rings)
# =============================================================================

func set_ring_items(ring_type: RingType, items: Array) -> void:
    rings[ring_type] = items
    if is_open and current_ring == ring_type:
        _refresh_ring()

func add_ring_item(ring_type: RingType, item: Dictionary) -> void:
    rings[ring_type].append(item)
    if is_open and current_ring == ring_type:
        _refresh_ring()

func remove_ring_item(ring_type: RingType, item_id: String) -> void:
    rings[ring_type] = rings[ring_type].filter(func(i): return i.get("id") != item_id)
    if is_open and current_ring == ring_type:
        _refresh_ring()
```

Add input action to project.godot:
```
ring_menu = Tab key

Add to Events autoload:
```gdscript
## Ring Menu Signals
signal ring_menu_opened
signal ring_menu_closed
signal ring_item_selected(ring_type: int, item: Dictionary)
```

ring_menu.tscn structure:
```
RingMenu (CanvasLayer)
└── Container (Control, centered, 250x250)
    ├── Background (ColorRect, dark semi-transparent circle)
    ├── CenterIcon (Control, center, shows selected item large)
    ├── RingLabel (Label, top, "Items" / "Equipment" / etc)
    ├── ItemNameLabel (Label, center-bottom, selected item name)
    ├── ItemDescLabel (Label, below name, description)
    └── (RingItems added dynamically)
```
  </action>
  <verify>
Ring menu scene loads without error
Tab opens menu, pauses game
Left/Right rotates through items smoothly
Up/Down switches rings
Tab or Cancel closes menu
Options ring has Save/Settings/Quit
  </verify>
  <done>Core ring menu with navigation and multiple rings working</done>
</task>

<task type="auto">
  <name>Task 3: Add visual polish and sounds</name>
  <files>
    ui/ring_menu/ring_menu.gd
    ui/ring_menu/ring_menu.tscn
    assets/audio/sfx/menu_open.wav
    assets/audio/sfx/menu_close.wav
    assets/audio/sfx/menu_switch.wav
    autoloads/audio_manager.gd
  </files>
  <action>
Add opening/closing animations to RingMenu:

```gdscript
# Add to RingMenu class

var open_tween: Tween
const OPEN_DURATION: float = 0.2
const CLOSE_DURATION: float = 0.15

func open_menu() -> void:
    if is_open:
        return
    
    is_open = true
    visible = true
    
    # Animate open (scale from 0 to 1, fade in)
    container.scale = Vector2.ZERO
    container.modulate.a = 0.0
    
    if open_tween:
        open_tween.kill()
    open_tween = create_tween()
    open_tween.set_ease(Tween.EASE_OUT)
    open_tween.set_trans(Tween.TRANS_BACK)
    open_tween.tween_property(container, "scale", Vector2.ONE, OPEN_DURATION)
    open_tween.parallel().tween_property(container, "modulate:a", 1.0, OPEN_DURATION * 0.5)
    
    # Pause game
    GameManager.pause_game()
    
    # Reset and refresh
    selected_index = 0
    current_rotation = 0.0
    target_rotation = 0.0
    _refresh_ring()
    
    AudioManager.play_sfx("menu_open")
    Events.ring_menu_opened.emit()

func close_menu() -> void:
    if not is_open:
        return
    
    is_open = false
    
    # Animate close
    if open_tween:
        open_tween.kill()
    open_tween = create_tween()
    open_tween.set_ease(Tween.EASE_IN)
    open_tween.set_trans(Tween.TRANS_BACK)
    open_tween.tween_property(container, "scale", Vector2.ZERO, CLOSE_DURATION)
    open_tween.parallel().tween_property(container, "modulate:a", 0.0, CLOSE_DURATION)
    open_tween.tween_callback(func(): visible = false)
    
    # Resume game
    GameManager.resume_game()
    
    AudioManager.play_sfx("menu_close")
    Events.ring_menu_closed.emit()
```

Create/add menu sounds to AudioManager:
- menu_open.wav: Whoosh/expand sound
- menu_close.wav: Quick whoosh/collapse
- menu_switch.wav: Ring change sound (different from navigate)

```gdscript
# In audio_manager.gd sfx dictionary:
"menu_open": preload("res://assets/audio/sfx/menu_open.wav"),
"menu_close": preload("res://assets/audio/sfx/menu_close.wav"),
"menu_switch": preload("res://assets/audio/sfx/menu_switch.wav"),
```

Generate placeholder sounds using Python or manually create simple .wav files.
  </action>
  <verify>
Menu opens with smooth scale animation
Menu closes with reverse animation
Different sounds for open/close/switch
Ring switching feels distinct from item navigation
  </verify>
  <done>Ring menu has polished animations and distinct sounds</done>
</task>

</tasks>

<verification>
1. Run game, enter gameplay
2. Press Tab - ring menu opens with animation, game pauses
3. Left/Right - items rotate smoothly around center
4. Selected item is larger and glowing
5. Center shows selected item name and description
6. Up/Down - switches between rings (Items/Equipment/Companions/Options)
7. Ring label updates when switching
8. Select "Quit" option - returns to title screen
9. Tab or X/Cancel - menu closes with animation, game resumes
</verification>

<success_criteria>
- Tab toggles ring menu open/closed
- Game pauses when menu is open
- 8 item slots arranged in circle
- Smooth rotation animation when selecting
- Up/Down switches between 4 rings
- Selected item highlighted (scale + glow)
- Center displays item name and description
- Opening/closing animations smooth
- Distinct sounds for all interactions
- Options ring has working Save/Settings/Quit
</success_criteria>

<output>
After completion, create `.planning/phases/16-ring-menu/16-01-SUMMARY.md`
</output>
