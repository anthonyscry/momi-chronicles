---
phase: 16-ring-menu
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - systems/inventory/inventory.gd
  - systems/inventory/item_database.gd
  - systems/inventory/item_effect.gd
  - ui/ring_menu/ring_menu.gd
  - autoloads/game_manager.gd
autonomous: true

must_haves:
  truths:
    - "Player has inventory that stores items"
    - "Items have defined effects (heal, buff, etc.)"
    - "Using item from ring menu applies effect"
    - "Consumables decrease in quantity"
    - "Empty items removed from ring"
    - "Items can be found/dropped in world"
  artifacts:
    - path: "systems/inventory/inventory.gd"
      provides: "Player inventory management"
      exports: ["Inventory"]
    - path: "systems/inventory/item_database.gd"
      provides: "Item definitions"
  key_links:
    - from: "ring_menu.gd"
      to: "inventory.gd"
      via: "_use_item calls inventory"
      pattern: "inventory\\.use_item"
    - from: "inventory.gd"
      to: "player"
      via: "apply item effects"
      pattern: "player\\.health\\.heal"
---

<objective>
Create the item and inventory system for usable consumables.

Purpose: Allow players to collect and use items like potions, food, and buffs
Output: Working inventory with usable items accessible from ring menu
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-ring-menu/16-01-SUMMARY.md
@ui/ring_menu/ring_menu.gd
@characters/player/player.gd
@autoloads/game_manager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Item Database</name>
  <files>
    systems/inventory/item_database.gd
  </files>
  <action>
Create item definitions and database:

```gdscript
extends Node
class_name ItemDatabase

## Item effect types
enum EffectType {
    HEAL,           # Restore HP
    HEAL_PERCENT,   # Restore % of max HP
    BUFF_ATTACK,    # Temporary attack boost
    BUFF_SPEED,     # Temporary speed boost
    BUFF_DEFENSE,   # Temporary damage reduction
    RESTORE_GUARD,  # Restore guard meter
    CURE_STATUS,    # Remove negative effects
    REVIVE,         # Revive companion (future)
}

## All item definitions
const ITEMS: Dictionary = {
    # === HEALING ITEMS ===
    "health_potion": {
        "id": "health_potion",
        "name": "Health Potion",
        "desc": "Restores 50 HP",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 10,
        "effect": EffectType.HEAL,
        "value": 50,
        "icon": null,  # Use placeholder
        "color": Color(1.0, 0.3, 0.3),  # Red
    },
    "mega_potion": {
        "id": "mega_potion",
        "name": "Mega Potion",
        "desc": "Restores 150 HP",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 5,
        "effect": EffectType.HEAL,
        "value": 150,
        "color": Color(1.0, 0.1, 0.5),  # Magenta
    },
    "full_heal": {
        "id": "full_heal",
        "name": "Full Heal",
        "desc": "Fully restores HP",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 3,
        "effect": EffectType.HEAL_PERCENT,
        "value": 1.0,  # 100%
        "color": Color(1.0, 0.8, 0.9),  # Pink
    },
    
    # === FOOD ITEMS (from enemy drops) ===
    "acorn": {
        "id": "acorn",
        "name": "Acorn",
        "desc": "A crunchy snack. Restores 15 HP",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 20,
        "effect": EffectType.HEAL,
        "value": 15,
        "color": Color(0.6, 0.4, 0.2),  # Brown
    },
    "bird_seed": {
        "id": "bird_seed",
        "name": "Bird Seed",
        "desc": "Nutritious seeds. Restores 10 HP",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 30,
        "effect": EffectType.HEAL,
        "value": 10,
        "color": Color(0.9, 0.85, 0.6),  # Tan
    },
    
    # === BUFF ITEMS ===
    "power_treat": {
        "id": "power_treat",
        "name": "Power Treat",
        "desc": "Attack +50% for 30 seconds",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 5,
        "effect": EffectType.BUFF_ATTACK,
        "value": 0.5,  # 50% boost
        "duration": 30.0,
        "color": Color(1.0, 0.5, 0.0),  # Orange
    },
    "speed_treat": {
        "id": "speed_treat",
        "name": "Speed Treat",
        "desc": "Speed +30% for 30 seconds",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 5,
        "effect": EffectType.BUFF_SPEED,
        "value": 0.3,
        "duration": 30.0,
        "color": Color(0.3, 0.9, 1.0),  # Cyan
    },
    "tough_treat": {
        "id": "tough_treat",
        "name": "Tough Treat",
        "desc": "Damage taken -30% for 30 seconds",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 5,
        "effect": EffectType.BUFF_DEFENSE,
        "value": 0.3,
        "duration": 30.0,
        "color": Color(0.5, 0.5, 0.8),  # Purple-blue
    },
    
    # === GUARD ITEMS (v1.2) ===
    "guard_snack": {
        "id": "guard_snack",
        "name": "Guard Snack",
        "desc": "Restores guard meter fully",
        "type": "item",
        "consumable": true,
        "stackable": true,
        "max_stack": 10,
        "effect": EffectType.RESTORE_GUARD,
        "value": 100.0,
        "color": Color(0.4, 0.6, 1.0),  # Blue
    },
}

## Get item data by ID
static func get_item(item_id: String) -> Dictionary:
    if ITEMS.has(item_id):
        return ITEMS[item_id].duplicate(true)
    push_error("Unknown item: %s" % item_id)
    return {}

## Get all items of a type
static func get_items_by_type(item_type: String) -> Array:
    var result = []
    for id in ITEMS:
        if ITEMS[id].type == item_type:
            result.append(ITEMS[id].duplicate(true))
    return result
```
  </action>
  <verify>
ItemDatabase.get_item("health_potion") returns valid data
All items have required fields (id, name, effect, value)
  </verify>
  <done>Item database with healing, food, and buff items defined</done>
</task>

<task type="auto">
  <name>Task 2: Create Inventory System</name>
  <files>
    systems/inventory/inventory.gd
    autoloads/game_manager.gd
  </files>
  <action>
Create inventory management system:

```gdscript
extends Node
class_name Inventory

signal item_added(item_id: String, quantity: int)
signal item_removed(item_id: String, quantity: int)
signal item_used(item_id: String)
signal inventory_changed

## Inventory slots: {item_id: quantity}
var items: Dictionary = {}

## Maximum unique item types
const MAX_SLOTS: int = 20

## Active buffs: {effect_type: {value, end_time}}
var active_buffs: Dictionary = {}

func _ready() -> void:
    # Give starting items
    add_item("health_potion", 3)
    add_item("acorn", 5)

func _process(delta: float) -> void:
    # Check buff expirations
    _update_buffs()

# =============================================================================
# INVENTORY MANAGEMENT
# =============================================================================

func add_item(item_id: String, quantity: int = 1) -> bool:
    var item_data = ItemDatabase.get_item(item_id)
    if item_data.is_empty():
        return false
    
    if items.has(item_id):
        # Stack existing
        var max_stack = item_data.get("max_stack", 99)
        items[item_id] = min(items[item_id] + quantity, max_stack)
    else:
        # New item
        if items.size() >= MAX_SLOTS:
            push_warning("Inventory full!")
            return false
        items[item_id] = quantity
    
    item_added.emit(item_id, quantity)
    inventory_changed.emit()
    return true

func remove_item(item_id: String, quantity: int = 1) -> bool:
    if not items.has(item_id):
        return false
    
    items[item_id] -= quantity
    
    if items[item_id] <= 0:
        items.erase(item_id)
    
    item_removed.emit(item_id, quantity)
    inventory_changed.emit()
    return true

func has_item(item_id: String, quantity: int = 1) -> bool:
    return items.get(item_id, 0) >= quantity

func get_quantity(item_id: String) -> int:
    return items.get(item_id, 0)

func get_all_items() -> Array[Dictionary]:
    var result: Array[Dictionary] = []
    for item_id in items:
        var item_data = ItemDatabase.get_item(item_id)
        item_data["quantity"] = items[item_id]
        result.append(item_data)
    return result

# =============================================================================
# ITEM USAGE
# =============================================================================

func use_item(item_id: String, target: Node = null) -> bool:
    if not has_item(item_id):
        return false
    
    var item_data = ItemDatabase.get_item(item_id)
    if item_data.is_empty():
        return false
    
    # Get target (default to player)
    if target == null:
        target = get_tree().get_first_node_in_group("player")
    
    if target == null:
        return false
    
    # Apply effect
    var success = _apply_item_effect(item_data, target)
    
    if success and item_data.get("consumable", false):
        remove_item(item_id, 1)
        item_used.emit(item_id)
        AudioManager.play_sfx("item_use")
    
    return success

func _apply_item_effect(item_data: Dictionary, target: Node) -> bool:
    var effect = item_data.get("effect", -1)
    var value = item_data.get("value", 0)
    
    match effect:
        ItemDatabase.EffectType.HEAL:
            if target.has_node("HealthComponent"):
                target.get_node("HealthComponent").heal(int(value))
                _spawn_heal_effect(target)
                return true
        
        ItemDatabase.EffectType.HEAL_PERCENT:
            if target.has_node("HealthComponent"):
                var health = target.get_node("HealthComponent")
                var heal_amount = int(health.max_health * value)
                health.heal(heal_amount)
                _spawn_heal_effect(target)
                return true
        
        ItemDatabase.EffectType.BUFF_ATTACK:
            _apply_buff(ItemDatabase.EffectType.BUFF_ATTACK, value, item_data.get("duration", 30.0))
            _spawn_buff_effect(target, item_data.get("color", Color.ORANGE))
            return true
        
        ItemDatabase.EffectType.BUFF_SPEED:
            _apply_buff(ItemDatabase.EffectType.BUFF_SPEED, value, item_data.get("duration", 30.0))
            _spawn_buff_effect(target, item_data.get("color", Color.CYAN))
            return true
        
        ItemDatabase.EffectType.BUFF_DEFENSE:
            _apply_buff(ItemDatabase.EffectType.BUFF_DEFENSE, value, item_data.get("duration", 30.0))
            _spawn_buff_effect(target, item_data.get("color", Color.PURPLE))
            return true
        
        ItemDatabase.EffectType.RESTORE_GUARD:
            if target.has_node("GuardComponent"):
                target.get_node("GuardComponent").restore_guard(value)
                return true
    
    return false

func _spawn_heal_effect(target: Node) -> void:
    if has_node("/root/EffectsManager"):
        get_node("/root/EffectsManager").spawn_pickup_effect(
            target.global_position, Color(0.3, 1.0, 0.3)
        )

func _spawn_buff_effect(target: Node, color: Color) -> void:
    if has_node("/root/EffectsManager"):
        get_node("/root/EffectsManager").spawn_pickup_effect(
            target.global_position, color
        )

# =============================================================================
# BUFF SYSTEM
# =============================================================================

func _apply_buff(effect_type: int, value: float, duration: float) -> void:
    var end_time = Time.get_ticks_msec() / 1000.0 + duration
    active_buffs[effect_type] = {"value": value, "end_time": end_time}
    Events.buff_applied.emit(effect_type, value, duration)

func _update_buffs() -> void:
    var current_time = Time.get_ticks_msec() / 1000.0
    var expired = []
    
    for effect_type in active_buffs:
        if current_time >= active_buffs[effect_type].end_time:
            expired.append(effect_type)
    
    for effect_type in expired:
        active_buffs.erase(effect_type)
        Events.buff_expired.emit(effect_type)

func get_buff_multiplier(effect_type: int) -> float:
    if active_buffs.has(effect_type):
        return 1.0 + active_buffs[effect_type].value
    return 1.0

func has_buff(effect_type: int) -> bool:
    return active_buffs.has(effect_type)
```

Add Inventory to GameManager:
```gdscript
# In game_manager.gd
var inventory: Inventory = null

func _ready() -> void:
    # ... existing code ...
    inventory = Inventory.new()
    add_child(inventory)
```

Add signals to Events:
```gdscript
signal buff_applied(effect_type: int, value: float, duration: float)
signal buff_expired(effect_type: int)
```
  </action>
  <verify>
GameManager.inventory exists
Can add/remove items
use_item heals player when using health_potion
Buffs apply and expire correctly
  </verify>
  <done>Inventory system with item usage and buff management</done>
</task>

<task type="auto">
  <name>Task 3: Connect Ring Menu to Inventory</name>
  <files>
    ui/ring_menu/ring_menu.gd
  </files>
  <action>
Update RingMenu to use inventory system:

```gdscript
# Update _refresh_ring to pull from inventory
func _refresh_ring() -> void:
    # Populate items ring from inventory
    if current_ring == RingType.ITEMS:
        rings[RingType.ITEMS] = _get_inventory_items()
    
    var items = rings[current_ring]
    
    # ... rest of existing _refresh_ring code ...

func _get_inventory_items() -> Array:
    if not GameManager.inventory:
        return []
    return GameManager.inventory.get_all_items()

# Update _use_item to actually use inventory
func _use_item(item: Dictionary) -> void:
    var item_id = item.get("id", "")
    if item_id.is_empty():
        return
    
    if GameManager.inventory.use_item(item_id):
        # Item used successfully
        # Refresh ring to update quantities
        _refresh_ring()
        
        # If item is now depleted, adjust selection
        var items = rings[RingType.ITEMS]
        if selected_index >= items.size():
            selected_index = max(0, items.size() - 1)
        
        _update_selection()
    else:
        # Failed to use (maybe at full health?)
        AudioManager.play_sfx("menu_error")  # Need this sound
```

Add error sound to AudioManager if not exists.
  </action>
  <verify>
Ring menu Items ring shows inventory contents
Using item from ring menu consumes it
Quantities update after use
Empty items disappear from ring
  </verify>
  <done>Ring menu connected to inventory, items usable</done>
</task>

</tasks>

<verification>
1. Start game - player has 3 Health Potions, 5 Acorns
2. Take damage from enemy
3. Open ring menu (Tab), Items ring selected by default
4. See Health Potion with "x3" quantity
5. Select and use Health Potion - HP restores, quantity becomes x2
6. Use all potions - item disappears from ring
7. Use Power Treat - see buff effect, attack increased for 30s
</verification>

<success_criteria>
- ItemDatabase defines 8+ items (healing, food, buffs)
- Inventory tracks items and quantities
- Items stack up to max_stack limit
- Using consumable decreases quantity
- Depleted items removed from inventory
- Healing items restore HP correctly
- Buff items apply timed effects
- Ring menu shows real inventory contents
- Item use feedback (sound, visual effect)
</success_criteria>

<output>
After completion, create `.planning/phases/16-ring-menu/16-02-SUMMARY.md`
</output>
