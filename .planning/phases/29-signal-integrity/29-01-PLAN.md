---
phase: 29-signal-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/menus/title_screen.gd
  - autoloads/game_manager.gd
  - ui/hud/game_hud.gd
autonomous: true

must_haves:
  truths:
    - "Corrupt save shows a visible red warning on the title screen with backup restore option"
    - "Loading a saved game refreshes health bar, coin counter, and EXP bar to loaded values"
    - "Restarting via game over clears active buffs, poison visuals, and combo counter"
  artifacts:
    - path: "ui/menus/title_screen.gd"
      provides: "save_corrupted handler with red warning text and backup restore prompt"
      contains: "Events.save_corrupted.connect"
    - path: "autoloads/game_manager.gd"
      provides: "game_restarted handler that clears buffs, poison, combo state"
      contains: "Events.game_restarted"
    - path: "ui/hud/game_hud.gd"
      provides: "game_loaded handler that refreshes all HUD elements"
      contains: "Events.game_loaded.connect"
  key_links:
    - from: "autoloads/save_manager.gd"
      to: "ui/menus/title_screen.gd"
      via: "Events.save_corrupted signal"
      pattern: "save_corrupted"
    - from: "autoloads/save_manager.gd"
      to: "ui/hud/game_hud.gd"
      via: "Events.game_loaded signal"
      pattern: "game_loaded"
    - from: "autoloads/game_manager.gd"
      to: "systems/inventory/inventory.gd"
      via: "active_buffs.clear() on restart"
      pattern: "active_buffs"
---

<objective>
Wire the 3 missing signal handlers for save_corrupted, game_loaded, and game_restarted.

Purpose: Players currently get silent failures on corrupt saves, stale HUD after loading, and lingering buffs/poison after restart. This wires the existing signals to proper handlers.

Output: Three working signal connections — corrupt save warning on title screen, HUD refresh on load, state clearing on restart.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@autoloads/events.gd
@autoloads/save_manager.gd
@autoloads/game_manager.gd
@ui/menus/title_screen.gd
@ui/hud/game_hud.gd
@ui/hud/health_bar.gd
@ui/hud/coin_counter.gd
@ui/hud/exp_bar.gd
@ui/hud/combo_counter.gd
@ui/hud/buff_icons.gd
@ui/hud/guard_bar.gd
@systems/inventory/inventory.gd
@components/health/health_component.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire save_corrupted signal to title screen warning</name>
  <files>ui/menus/title_screen.gd</files>
  <action>
In title_screen.gd, connect Events.save_corrupted to a handler in _ready().

The handler logic:
1. Set a flag `_save_is_corrupted = true` when save_corrupted fires
2. In `_do_load_game()`, the load already fails and returns to title. Enhance this:
   - When load fails AND `_save_is_corrupted` is true:
   - Check if SaveManager.BACKUP_PATH exists (FileAccess.file_exists)
   - If backup exists: show red-tinted warning text "Save corrupted. Backup found — restore?" with two options: "Restore Backup" (copies backup to main save path, retries load) and "Start Fresh" (deletes save, starts new game)
   - If no backup: show "Save corrupted. Start fresh?" with only "Start Fresh" option
3. The warning UI should be programmatic (matching existing pattern — Label + Button nodes created in code):
   - A Label with red text (Color(1, 0.4, 0.4)) positioned center-screen
   - Use the existing ConfirmationDialog node ($ConfirmationDialog) for the restore/fresh choice
4. If backup restore succeeds, show a brief "Restored from backup" Label that fades out after 2 seconds. Connect Events.zone_entered (one-shot) to show this note on the game HUD level (create a temporary Label child on the root, position top-center, fade out with tween).

Important:
- Do NOT modify save_manager.gd — it already emits save_corrupted correctly
- The signal fires DURING _read_save_file(), before load_game() returns false
- So connect save_corrupted BEFORE _do_load_game could fire (in _ready is fine)
- Use process_mode = PROCESS_MODE_ALWAYS on any warning UI nodes (title screen may be paused)
  </action>
  <verify>
Read the modified title_screen.gd and confirm:
1. Events.save_corrupted.connect exists in _ready()
2. Handler creates visible warning UI
3. Backup check with FileAccess.file_exists(SaveManager.BACKUP_PATH)
4. Restore logic copies backup file and retries load
5. "Start Fresh" path calls SaveManager.delete_save() then starts new game
  </verify>
  <done>
save_corrupted signal has a connected handler that shows player-visible feedback on the title screen. Backup restore path exists. Start fresh path exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire game_loaded signal to refresh all HUD elements</name>
  <files>ui/hud/game_hud.gd</files>
  <action>
In game_hud.gd, connect Events.game_loaded to a handler in _ready().

The handler `_on_game_loaded()` should:
1. Wait 2 frames (await get_tree().process_frame twice) — same pattern as save_manager's _on_zone_entered_after_load, so player is spawned
2. Get the player: `get_tree().get_first_node_in_group("player")`
3. Refresh health bar: If player has HealthComponent, emit Events.player_health_changed with player's current health/max health so HealthBar updates
4. Refresh coin counter: Emit Events.coins_changed with GameManager.coins so CoinCounter updates
5. Refresh EXP bar: If player has Progression component, emit Events.exp_gained with current values so ExpBar updates. Also emit Events.player_leveled_up with current level.
6. Refresh guard bar: If player has GuardComponent, emit Events.guard_changed with current/max guard values

The key insight: all HUD elements already listen to Events signals. The simplest approach is to re-emit the relevant signals with current values after load, rather than adding new update methods to each HUD element.

Important:
- The save_manager already emits game_loaded at the END of _apply_save_data(), and zone_entered fires AFTER that
- game_hud connects to game_loaded, waits for player to exist, then re-broadcasts current state
- Do NOT modify any HUD child scripts — they already handle Events signals correctly
- Guard value comes from player's GuardComponent if it exists (get_node_or_null("GuardComponent"))
  </action>
  <verify>
Read the modified game_hud.gd and confirm:
1. Events.game_loaded.connect exists in _ready()
2. Handler waits for process frames
3. Re-emits player_health_changed, coins_changed, exp_gained, player_leveled_up, guard_changed with current values
4. Null-safe: checks player, HealthComponent, Progression, GuardComponent existence
  </verify>
  <done>
Loading a saved game triggers HUD refresh — health bar, coin counter, EXP bar, and guard bar all update to loaded values.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire game_restarted signal to clear temporary state</name>
  <files>autoloads/game_manager.gd</files>
  <action>
In game_manager.gd, the restart_game() function already emits Events.game_restarted. The problem is nobody listens. But more importantly, the state clearing should happen IN restart_game() itself, not in external listeners, since GameManager owns the restart flow.

Modify restart_game() in game_manager.gd to clear temporary state BEFORE reload_current_scene():

```gdscript
func restart_game() -> void:
    is_player_alive = true
    is_paused = false
    get_tree().paused = false
    
    # Clear temporary state before scene reload
    _clear_temporary_state()
    
    get_tree().reload_current_scene()
    Events.game_restarted.emit()
```

Add the helper method `_clear_temporary_state()`:
1. Clear active buffs: `inventory.active_buffs.clear()` — this prevents stale buff timers. Also emit Events.buff_expired for each active buff type so BuffIcons clears its display.
2. The combo counter, poison visuals, and health are all scene-tree nodes that get destroyed by reload_current_scene(). So they reset naturally. BUT buff data lives in Inventory (an autoload child) which survives scene reload.
3. That's the only state that persists incorrectly — Inventory.active_buffs is on an autoload child, not a scene-tree node.

So the fix is specifically:
```gdscript
func _clear_temporary_state() -> void:
    # Clear active buffs (Inventory is autoload child, survives scene reload)
    if inventory:
        for effect_type in inventory.active_buffs.keys():
            Events.buff_expired.emit(effect_type)
        inventory.active_buffs.clear()
```

Important:
- combo_counter is a scene node — destroyed on reload, resets naturally
- poison state is on HealthComponent — destroyed on reload, resets naturally  
- buff icons are scene nodes — destroyed on reload, but we emit buff_expired anyway for clean lifecycle
- guard meter is on GuardComponent — destroyed on reload, resets naturally
- Inventory.active_buffs is the ONLY stale state that survives reload
  </action>
  <verify>
Read the modified game_manager.gd and confirm:
1. _clear_temporary_state() method exists
2. It clears inventory.active_buffs
3. It emits buff_expired for each active buff type before clearing
4. restart_game() calls _clear_temporary_state() before reload_current_scene()
  </verify>
  <done>
Restarting the game clears all active buffs. Combo counter, poison visuals, and guard meter reset naturally via scene reload. No stale temporary state persists across restart.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Grep for `save_corrupted.connect` — should find title_screen.gd
2. Grep for `game_loaded.connect` — should find game_hud.gd
3. Grep for `_clear_temporary_state` — should find game_manager.gd
4. Grep for `buff_expired.emit` in game_manager.gd — confirms buff clearing
5. All 3 previously unconnected signals now have handlers
</verification>

<success_criteria>
1. Events.save_corrupted has a connected handler in title_screen.gd that shows visible warning
2. Events.game_loaded has a connected handler in game_hud.gd that refreshes HUD elements
3. GameManager.restart_game() clears Inventory.active_buffs before scene reload
4. No new signals created — only connections to existing signals
</success_criteria>

<output>
After completion, create `.planning/phases/29-signal-integrity/29-01-SUMMARY.md`
</output>
