---
phase: 15-ui-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autoloads/ui_tester.gd
  - project.godot
autonomous: true

must_haves:
  truths:
    - "UITester can find any UI element by name"
    - "UITester can click buttons programmatically"
    - "UITester can verify label text content"
    - "UITester can verify node visibility"
    - "UITester can verify progress bar values"
    - "F2 toggles UI test mode"
  artifacts:
    - path: "autoloads/ui_tester.gd"
      provides: "UI testing automation framework"
      exports: ["UITester"]
  key_links:
    - from: "ui_tester.gd"
      to: "scene tree"
      via: "find_child recursive search"
      pattern: "find_child.*true.*false"
---

<objective>
Create UITester autoload with helper functions for automated UI testing.

Purpose: Enable automated verification of UI elements and interactions
Output: Reusable UI testing framework integrated as autoload
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@autoloads/auto_bot.gd
@ui/menus/title_screen.gd
@ui/menus/pause_menu.gd
@ui/hud/game_hud.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UITester autoload</name>
  <files>
    autoloads/ui_tester.gd
    project.godot
  </files>
  <action>
Create UITester autoload with core helper functions:

```gdscript
extends Node
## UITester - Automated UI testing framework
## Toggle with F2. Runs test scenarios to verify UI functionality.

# =============================================================================
# CONFIGURATION
# =============================================================================

## Whether UI testing mode is active
var enabled: bool = false

## Test results tracking
var tests_run: int = 0
var tests_passed: int = 0
var tests_failed: int = 0
var current_test: String = ""
var test_log: Array[String] = []

## Timing
const CLICK_DELAY: float = 0.1  # Delay after clicking
const VERIFY_DELAY: float = 0.05  # Delay before verifying

# =============================================================================
# LIFECYCLE
# =============================================================================

func _ready() -> void:
    print("[UITester] Ready - Press F2 to run UI tests")

func _unhandled_input(event: InputEvent) -> void:
    if event is InputEventKey and event.pressed and not event.echo:
        if event.keycode == KEY_F2:
            if not enabled:
                start_tests()
            else:
                stop_tests()

# =============================================================================
# TEST CONTROL
# =============================================================================

func start_tests() -> void:
    enabled = true
    tests_run = 0
    tests_passed = 0
    tests_failed = 0
    test_log.clear()
    log_info("=== UI TESTS STARTED ===")

func stop_tests() -> void:
    enabled = false
    log_info("=== UI TESTS STOPPED ===")
    print_report()

func print_report() -> void:
    print("\n" + "=".repeat(50))
    print("UI TEST REPORT")
    print("=".repeat(50))
    print("Tests Run: %d" % tests_run)
    print("Passed: %d" % tests_passed)
    print("Failed: %d" % tests_failed)
    print("Success Rate: %.1f%%" % (100.0 * tests_passed / max(tests_run, 1)))
    print("=".repeat(50))
    for entry in test_log:
        print(entry)
    print("=".repeat(50) + "\n")

# =============================================================================
# LOGGING
# =============================================================================

func log_info(msg: String) -> void:
    var entry = "[INFO] %s" % msg
    test_log.append(entry)
    print("[UITester] %s" % msg)

func log_pass(test_name: String, detail: String = "") -> void:
    tests_run += 1
    tests_passed += 1
    var entry = "[PASS] %s%s" % [test_name, " - " + detail if detail else ""]
    test_log.append(entry)
    print("[UITester] ✓ %s" % test_name)

func log_fail(test_name: String, reason: String) -> void:
    tests_run += 1
    tests_failed += 1
    var entry = "[FAIL] %s - %s" % [test_name, reason]
    test_log.append(entry)
    print("[UITester] ✗ %s: %s" % [test_name, reason])

# =============================================================================
# UI ELEMENT FINDERS
# =============================================================================

## Find any node by name (recursive search from scene root)
func find_node(node_name: String) -> Node:
    return get_tree().root.find_child(node_name, true, false)

## Find a Control node by name
func find_control(node_name: String) -> Control:
    var node = find_node(node_name)
    return node as Control if node is Control else null

## Find a Button by name
func find_button(button_name: String) -> BaseButton:
    var node = find_node(button_name)
    return node as BaseButton if node is BaseButton else null

## Find a Label by name
func find_label(label_name: String) -> Label:
    var node = find_node(label_name)
    return node as Label if node is Label else null

## Find a ProgressBar or Range by name
func find_bar(bar_name: String) -> Range:
    var node = find_node(bar_name)
    return node as Range if node is Range else null

## Find a Slider by name
func find_slider(slider_name: String) -> Slider:
    var node = find_node(slider_name)
    return node as Slider if node is Slider else null

# =============================================================================
# UI INTERACTIONS
# =============================================================================

## Click a button by name, returns true if successful
func click_button(button_name: String) -> bool:
    var btn = find_button(button_name)
    if btn and btn.visible and not btn.disabled:
        btn.emit_signal("pressed")
        return true
    return false

## Set slider value by name
func set_slider(slider_name: String, value: float) -> bool:
    var slider = find_slider(slider_name)
    if slider and slider.visible:
        slider.value = value
        slider.emit_signal("value_changed", value)
        return true
    return false

## Focus a control by name
func focus_control(control_name: String) -> bool:
    var ctrl = find_control(control_name)
    if ctrl and ctrl.visible:
        ctrl.grab_focus()
        return true
    return false

## Simulate key press (for menu navigation)
func press_key(keycode: int) -> void:
    var event = InputEventKey.new()
    event.keycode = keycode
    event.pressed = true
    Input.parse_input_event(event)
    
    # Release after short delay
    await get_tree().create_timer(0.05).timeout
    event.pressed = false
    Input.parse_input_event(event)

# =============================================================================
# VERIFICATION HELPERS
# =============================================================================

## Verify a node exists
func verify_exists(node_name: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "exists:%s" % node_name
    var node = find_node(node_name)
    if node:
        log_pass(name)
        return true
    else:
        log_fail(name, "Node not found: %s" % node_name)
        return false

## Verify a node is visible
func verify_visible(node_name: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "visible:%s" % node_name
    var node = find_node(node_name)
    if not node:
        log_fail(name, "Node not found: %s" % node_name)
        return false
    if node is CanvasItem and node.visible:
        log_pass(name)
        return true
    elif node is CanvasLayer and node.visible:
        log_pass(name)
        return true
    else:
        log_fail(name, "Node not visible: %s" % node_name)
        return false

## Verify a node is hidden
func verify_hidden(node_name: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "hidden:%s" % node_name
    var node = find_node(node_name)
    if not node:
        log_pass(name, "Node doesn't exist (counts as hidden)")
        return true
    if node is CanvasItem and not node.visible:
        log_pass(name)
        return true
    elif node is CanvasLayer and not node.visible:
        log_pass(name)
        return true
    else:
        log_fail(name, "Node is visible: %s" % node_name)
        return false

## Verify label contains text
func verify_label_contains(label_name: String, expected: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "label:%s contains '%s'" % [label_name, expected]
    var label = find_label(label_name)
    if not label:
        log_fail(name, "Label not found: %s" % label_name)
        return false
    if expected in label.text:
        log_pass(name)
        return true
    else:
        log_fail(name, "Label text '%s' doesn't contain '%s'" % [label.text, expected])
        return false

## Verify label equals text
func verify_label_equals(label_name: String, expected: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "label:%s == '%s'" % [label_name, expected]
    var label = find_label(label_name)
    if not label:
        log_fail(name, "Label not found: %s" % label_name)
        return false
    if label.text == expected:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected '%s', got '%s'" % [expected, label.text])
        return false

## Verify progress bar value (with tolerance)
func verify_bar_value(bar_name: String, expected: float, tolerance: float = 0.01, test_name: String = "") -> bool:
    var name = test_name if test_name else "bar:%s ~= %.2f" % [bar_name, expected]
    var bar = find_bar(bar_name)
    if not bar:
        log_fail(name, "Bar not found: %s" % bar_name)
        return false
    if abs(bar.value - expected) <= tolerance:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected %.2f, got %.2f" % [expected, bar.value])
        return false

## Verify bar percentage (value/max)
func verify_bar_percent(bar_name: String, expected_percent: float, tolerance: float = 0.01, test_name: String = "") -> bool:
    var name = test_name if test_name else "bar:%s ~= %.0f%%" % [bar_name, expected_percent * 100]
    var bar = find_bar(bar_name)
    if not bar:
        log_fail(name, "Bar not found: %s" % bar_name)
        return false
    var actual_percent = bar.value / bar.max_value if bar.max_value > 0 else 0
    if abs(actual_percent - expected_percent) <= tolerance:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected %.0f%%, got %.0f%%" % [expected_percent * 100, actual_percent * 100])
        return false

## Verify button is enabled
func verify_button_enabled(button_name: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "button:%s enabled" % button_name
    var btn = find_button(button_name)
    if not btn:
        log_fail(name, "Button not found: %s" % button_name)
        return false
    if not btn.disabled:
        log_pass(name)
        return true
    else:
        log_fail(name, "Button is disabled")
        return false

## Verify current scene name
func verify_scene(expected_name: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "scene:%s" % expected_name
    var current = get_tree().current_scene
    if current and expected_name in current.name:
        log_pass(name)
        return true
    else:
        var actual = current.name if current else "null"
        log_fail(name, "Expected scene '%s', got '%s'" % [expected_name, actual])
        return false

# =============================================================================
# WAIT HELPERS
# =============================================================================

## Wait for a condition to be true (with timeout)
func wait_for(condition: Callable, timeout: float = 2.0, poll_interval: float = 0.1) -> bool:
    var elapsed = 0.0
    while elapsed < timeout:
        if condition.call():
            return true
        await get_tree().create_timer(poll_interval).timeout
        elapsed += poll_interval
    return false

## Wait for node to exist
func wait_for_node(node_name: String, timeout: float = 2.0) -> bool:
    return await wait_for(func(): return find_node(node_name) != null, timeout)

## Wait for node to be visible
func wait_for_visible(node_name: String, timeout: float = 2.0) -> bool:
    return await wait_for(func(): 
        var n = find_node(node_name)
        return n and n is CanvasItem and n.visible
    , timeout)

## Wait specified seconds
func wait_seconds(seconds: float) -> void:
    await get_tree().create_timer(seconds).timeout
```

Add to project.godot autoloads:
```
[autoload]
UITester="*res://autoloads/ui_tester.gd"
```

Place UITester AFTER Events, GameManager, AudioManager, AutoBot in the autoload order.
  </action>
  <verify>
Run game - "[UITester] Ready" should print
Press F2 - should print "=== UI TESTS STARTED ==="
Press F2 again - should print report
  </verify>
  <done>UITester autoload exists with all helper functions, F2 toggle works</done>
</task>

<task type="auto">
  <name>Task 2: Add GameManager/Event state helpers</name>
  <files>
    autoloads/ui_tester.gd
  </files>
  <action>
Add helpers that query game state for verification:

```gdscript
# =============================================================================
# GAME STATE VERIFICATION
# =============================================================================

## Verify game is paused
func verify_paused(test_name: String = "game:paused") -> bool:
    if GameManager.is_paused:
        log_pass(test_name)
        return true
    else:
        log_fail(test_name, "Game is not paused")
        return false

## Verify game is not paused
func verify_not_paused(test_name: String = "game:running") -> bool:
    if not GameManager.is_paused:
        log_pass(test_name)
        return true
    else:
        log_fail(test_name, "Game is paused")
        return false

## Verify player is alive
func verify_player_alive(test_name: String = "player:alive") -> bool:
    if GameManager.is_player_alive:
        log_pass(test_name)
        return true
    else:
        log_fail(test_name, "Player is dead")
        return false

## Verify current zone
func verify_zone(expected_zone: String, test_name: String = "") -> bool:
    var name = test_name if test_name else "zone:%s" % expected_zone
    if GameManager.current_zone == expected_zone:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected zone '%s', got '%s'" % [expected_zone, GameManager.current_zone])
        return false

## Get player reference
func get_player() -> Node:
    return get_tree().get_first_node_in_group("player")

## Verify player health
func verify_player_health(expected: int, tolerance: int = 0, test_name: String = "") -> bool:
    var name = test_name if test_name else "player:health=%d" % expected
    var player = get_player()
    if not player or not player.health:
        log_fail(name, "Player or health component not found")
        return false
    var current = player.health.current_health
    if abs(current - expected) <= tolerance:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected %d HP, got %d" % [expected, current])
        return false

## Verify player health percentage
func verify_player_health_percent(expected_percent: float, tolerance: float = 0.05, test_name: String = "") -> bool:
    var name = test_name if test_name else "player:health=%.0f%%" % (expected_percent * 100)
    var player = get_player()
    if not player or not player.health:
        log_fail(name, "Player or health component not found")
        return false
    var percent = float(player.health.current_health) / float(player.health.max_health)
    if abs(percent - expected_percent) <= tolerance:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected %.0f%%, got %.0f%%" % [expected_percent * 100, percent * 100])
        return false

## Verify player level (for v1.1+ with progression)
func verify_player_level(expected: int, test_name: String = "") -> bool:
    var name = test_name if test_name else "player:level=%d" % expected
    var player = get_player()
    if not player:
        log_fail(name, "Player not found")
        return false
    if player.has_method("get_current_level"):
        var level = player.get_current_level()
        if level == expected:
            log_pass(name)
            return true
        else:
            log_fail(name, "Expected level %d, got %d" % [expected, level])
            return false
    else:
        log_fail(name, "Player has no get_current_level method")
        return false

## Verify coins (for v1.2+ with items)
func verify_coins(expected: int, test_name: String = "") -> bool:
    var name = test_name if test_name else "coins=%d" % expected
    if not GameManager.has_method("get_coins"):
        log_fail(name, "GameManager has no get_coins method (v1.2 feature)")
        return false
    var coins = GameManager.get_coins()
    if coins == expected:
        log_pass(name)
        return true
    else:
        log_fail(name, "Expected %d coins, got %d" % [expected, coins])
        return false

## Verify coins at least
func verify_coins_at_least(minimum: int, test_name: String = "") -> bool:
    var name = test_name if test_name else "coins>=%d" % minimum
    if not GameManager.has_method("get_coins"):
        log_fail(name, "GameManager has no get_coins method")
        return false
    var coins = GameManager.get_coins()
    if coins >= minimum:
        log_pass(name, "has %d" % coins)
        return true
    else:
        log_fail(name, "Expected >= %d coins, got %d" % [minimum, coins])
        return false
```
  </action>
  <verify>
UITester has verify_paused, verify_zone, verify_player_health methods
Methods log pass/fail correctly
  </verify>
  <done>Game state verification helpers added</done>
</task>

</tasks>

<verification>
1. Run game
2. Press F2 - UI tests start
3. Call UITester methods from console or test code:
   - `UITester.verify_visible("HealthBar")` 
   - `UITester.verify_scene("neighborhood")`
   - `UITester.click_button("StartButton")`
4. Press F2 - test report prints with pass/fail counts
</verification>

<success_criteria>
- UITester autoload registered and loads without error
- F2 toggles test mode on/off
- All finder methods work (find_node, find_button, find_label, etc.)
- All interaction methods work (click_button, set_slider, press_key)
- All verification methods work and log pass/fail
- Test report prints summary at end
- Game state helpers query GameManager correctly
</success_criteria>

<output>
After completion, create `.planning/phases/15-ui-testing/15-01-SUMMARY.md`
</output>
