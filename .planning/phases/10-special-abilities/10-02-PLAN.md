---
phase: 10-special-abilities
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - characters/player/states/player_ground_pound.gd (NEW)
  - characters/player/player.tscn
  - characters/player/player.gd
  - characters/enemies/enemy_base.gd
  - autoloads/events.gd
autonomous: true

must_haves:
  truths:
    - "Ground pound hits all enemies in AoE"
    - "Ground pound stuns enemies briefly"
    - "Ability unlocks at level 5"
  artifacts:
    - path: "characters/player/states/player_ground_pound.gd"
      provides: "Ground pound state logic"
  key_links:
    - from: "player_ground_pound.gd"
      to: "enemy_base.gd"
      via: "stun effect application"
---

<objective>
Implement ground pound AoE attack with stun effect, unlocked at level 5.

Purpose: Give player crowd control ability for multiple enemies
Output: AoE slam attack that damages and stuns nearby enemies
</objective>

<context>
@characters/player/player.gd (player class)
@characters/enemies/enemy_base.gd (enemy for stun)
@autoloads/events.gd (signals)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ground Pound State</name>
  <files>characters/player/states/player_ground_pound.gd</files>
  <action>
Create ground pound state (Special Attack key):

```gdscript
extends State
class_name PlayerGroundPound
## Ground Pound - AoE attack that damages and stuns nearby enemies
## Unlocked at level 5

# =============================================================================
# CONFIGURATION
# =============================================================================

## Level required to use this ability
const UNLOCK_LEVEL: int = 5

## Cooldown between uses
const COOLDOWN: float = 3.0

## Jump up duration
const JUMP_DURATION: float = 0.25

## Slam down duration
const SLAM_DURATION: float = 0.15

## Recovery duration
const RECOVERY_DURATION: float = 0.3

## Area of effect radius
const AOE_RADIUS: float = 50.0

## Damage dealt
const DAMAGE: int = 40

## Stun duration applied to enemies
const STUN_DURATION: float = 1.5

## Jump height (visual only in 2D)
const JUMP_HEIGHT: float = 20.0

# =============================================================================
# STATE
# =============================================================================

enum Phase { JUMP, SLAM, RECOVERY }
var current_phase: Phase = Phase.JUMP
var phase_timer: float = 0.0
var original_y: float = 0.0

# Static cooldown tracking
static var cooldown_remaining: float = 0.0

# =============================================================================
# LIFECYCLE
# =============================================================================

func enter() -> void:
    # Check if ability is unlocked
    if player.progression and player.progression.get_level() < UNLOCK_LEVEL:
        # Not unlocked - return to idle
        push_warning("Ground Pound not unlocked (need level %d)" % UNLOCK_LEVEL)
        state_machine.transition_to("Idle")
        return
    
    # Check cooldown
    if cooldown_remaining > 0:
        push_warning("Ground Pound on cooldown: %.1f" % cooldown_remaining)
        state_machine.transition_to("Idle")
        return
    
    player.velocity = Vector2.ZERO
    current_phase = Phase.JUMP
    phase_timer = 0.0
    original_y = player.global_position.y
    
    # Start jump animation
    _start_jump()
    
    Events.player_ground_pound_started.emit()

func exit() -> void:
    # Reset position
    player.global_position.y = original_y
    
    # Reset sprite
    if player.sprite:
        player.sprite.scale = Vector2.ONE
        player.sprite.modulate = Color.WHITE

func physics_update(delta: float) -> void:
    phase_timer += delta
    
    match current_phase:
        Phase.JUMP:
            _update_jump(delta)
        Phase.SLAM:
            _update_slam(delta)
        Phase.RECOVERY:
            _update_recovery(delta)

func _process(delta: float) -> void:
    # Update static cooldown (runs even when not in this state)
    if cooldown_remaining > 0:
        cooldown_remaining -= delta

# =============================================================================
# PHASES
# =============================================================================

func _start_jump() -> void:
    # Visual: scale up and glow
    if player.sprite:
        player.sprite.modulate = Color(1.2, 1.1, 0.9)

func _update_jump(delta: float) -> void:
    # Arc upward
    var progress = phase_timer / JUMP_DURATION
    var height_offset = sin(progress * PI) * JUMP_HEIGHT
    player.global_position.y = original_y - height_offset
    
    # Scale effect
    if player.sprite:
        player.sprite.scale = Vector2(1.0 + progress * 0.2, 1.0 - progress * 0.1)
    
    if phase_timer >= JUMP_DURATION:
        current_phase = Phase.SLAM
        phase_timer = 0.0
        _start_slam()

func _start_slam() -> void:
    # Slam down fast
    if player.sprite:
        player.sprite.modulate = Color(1.4, 1.2, 0.8)
        player.sprite.scale = Vector2(0.8, 1.3)

func _update_slam(delta: float) -> void:
    # Fast descent
    var progress = phase_timer / SLAM_DURATION
    var ease_progress = progress * progress  # Ease in (accelerate)
    player.global_position.y = original_y - JUMP_HEIGHT * (1.0 - ease_progress)
    
    if phase_timer >= SLAM_DURATION:
        current_phase = Phase.RECOVERY
        phase_timer = 0.0
        _do_impact()

func _do_impact() -> void:
    # Return to ground
    player.global_position.y = original_y
    
    # Deal AoE damage and stun
    _hit_enemies_in_range()
    
    # Visual effects
    _create_impact_effect()
    EffectsManager.screen_shake(15.0, 0.3)
    
    # Start cooldown
    cooldown_remaining = COOLDOWN
    
    Events.player_ground_pound_impact.emit(DAMAGE, AOE_RADIUS)

func _update_recovery(delta: float) -> void:
    # Brief recovery
    if player.sprite:
        player.sprite.scale = player.sprite.scale.lerp(Vector2.ONE, delta * 8)
        player.sprite.modulate = player.sprite.modulate.lerp(Color.WHITE, delta * 5)
    
    if phase_timer >= RECOVERY_DURATION:
        state_machine.transition_to("Idle")

# =============================================================================
# IMPACT
# =============================================================================

func _hit_enemies_in_range() -> void:
    var enemies = get_tree().get_nodes_in_group("enemies")
    
    for enemy in enemies:
        if not is_instance_valid(enemy):
            continue
        
        var distance = player.global_position.distance_to(enemy.global_position)
        if distance <= AOE_RADIUS:
            # Calculate damage (reduced at edges)
            var falloff = 1.0 - (distance / AOE_RADIUS) * 0.5  # 100% at center, 50% at edge
            var final_damage = int(DAMAGE * falloff)
            
            # Apply level bonus
            if player.progression:
                final_damage += player.progression.get_stat_bonus("attack_damage")
            
            # Damage enemy
            if enemy.health:
                enemy.health.take_damage(final_damage)
            
            # Apply stun
            if enemy.has_method("apply_stun"):
                enemy.apply_stun(STUN_DURATION)
            
            # Knockback away from player
            var knockback_dir = (enemy.global_position - player.global_position).normalized()
            enemy.velocity = knockback_dir * 150
            
            # Visual feedback
            Events.enemy_damaged.emit(enemy, final_damage)

func _create_impact_effect() -> void:
    # Create expanding ring
    var ring_count = 2
    for i in range(ring_count):
        var delay = i * 0.05
        _spawn_ring(player.global_position, delay, AOE_RADIUS * (0.5 + i * 0.3))
    
    # Dust particles
    for j in range(12):
        var angle = j * TAU / 12
        var dust = ColorRect.new()
        dust.size = Vector2(3, 3)
        dust.color = Color(0.6, 0.5, 0.4, 0.8)
        dust.global_position = player.global_position
        dust.z_index = 50
        get_tree().current_scene.add_child(dust)
        
        var end_pos = player.global_position + Vector2(cos(angle), sin(angle)) * AOE_RADIUS
        var tween = create_tween()
        tween.set_parallel(true)
        tween.tween_property(dust, "global_position", end_pos, 0.3).set_ease(Tween.EASE_OUT)
        tween.tween_property(dust, "modulate:a", 0.0, 0.3)
        tween.chain().tween_callback(dust.queue_free)

func _spawn_ring(pos: Vector2, delay: float, radius: float) -> void:
    await get_tree().create_timer(delay).timeout
    
    # Create circle of particles
    var segments = 16
    for i in range(segments):
        var angle = i * TAU / segments
        var particle = ColorRect.new()
        particle.size = Vector2(4, 4)
        particle.color = Color(1, 0.9, 0.5, 0.9)
        particle.global_position = pos
        particle.z_index = 60
        get_tree().current_scene.add_child(particle)
        
        var end_pos = pos + Vector2(cos(angle), sin(angle)) * radius
        var tween = create_tween()
        tween.set_parallel(true)
        tween.tween_property(particle, "global_position", end_pos, 0.2).set_ease(Tween.EASE_OUT)
        tween.tween_property(particle, "modulate:a", 0.0, 0.25)
        tween.chain().tween_callback(particle.queue_free)
```
  </action>
  <verify>File exists with ground pound logic</verify>
  <done>Ground pound state with AoE and stun</done>
</task>

<task type="auto">
  <name>Task 2: Add Stun System to Enemies</name>
  <files>characters/enemies/enemy_base.gd</files>
  <action>
Add stun mechanics to enemy base:

```gdscript
# Add to EnemyBase class

# =============================================================================
# STUN STATE
# =============================================================================

var is_stunned: bool = false
var stun_timer: float = 0.0

func _process(delta: float) -> void:
    # Existing cooldown logic...
    if not can_attack:
        attack_timer -= delta
        if attack_timer <= 0:
            can_attack = true
    
    # Stun timer
    if is_stunned:
        stun_timer -= delta
        if stun_timer <= 0:
            _end_stun()

## Apply stun effect
func apply_stun(duration: float) -> void:
    is_stunned = true
    stun_timer = duration
    
    # Visual feedback
    if sprite:
        sprite.modulate = Color(0.7, 0.7, 1.0)  # Blue tint for stunned
    
    # Stop movement
    velocity = Vector2.ZERO
    
    # Transition to stunned/idle state if available
    if state_machine and state_machine.has_node("Idle"):
        state_machine.transition_to("Idle")

func _end_stun() -> void:
    is_stunned = false
    
    # Reset visual
    if sprite:
        sprite.modulate = Color.WHITE

## Check if enemy can act (for AI states)
func can_act() -> bool:
    return not is_stunned and is_alive()
```

Update enemy states (idle, patrol, chase, attack) to check `can_act()`:

In enemy_idle.gd, enemy_chase.gd, enemy_attack.gd:
```gdscript
func physics_update(delta: float) -> void:
    if not enemy.can_act():
        enemy.velocity = Vector2.ZERO
        return
    
    # ... rest of existing logic ...
```
  </action>
  <verify>Enemies have apply_stun method, states check can_act()</verify>
  <done>Stun system added to enemies</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Ground Pound and Add Signals</name>
  <files>characters/player/player.tscn, characters/player/player.gd, autoloads/events.gd</files>
  <action>
1. In player.tscn StateMachine:
   - Add GroundPound state node (script: player_ground_pound.gd)

2. In events.gd, add ground pound signals:
```gdscript
# =============================================================================
# GROUND POUND SIGNALS
# =============================================================================

## Emitted when ground pound starts
signal player_ground_pound_started

## Emitted when ground pound impacts
signal player_ground_pound_impact(damage: int, radius: float)
```

3. In player states (idle, walk, run), handle special attack input:
```gdscript
# In physics_update, after attack handling:

# Special attack (ground pound)
if Input.is_action_just_pressed("special_attack"):
    state_machine.transition_to("GroundPound")
    return
```

4. In player.gd, add helper for ability unlock check:
```gdscript
func is_ability_unlocked(ability_name: String) -> bool:
    if not progression:
        return false
    
    match ability_name:
        "ground_pound":
            return progression.get_level() >= 5
        _:
            return true

func get_ground_pound_cooldown() -> float:
    return PlayerGroundPound.cooldown_remaining
```
  </action>
  <verify>Ground Pound triggers on special attack, requires level 5</verify>
  <done>Ground pound fully integrated</done>
</task>

</tasks>

<verification>
1. Run game at level 1 → special attack does nothing (not unlocked)
2. Cheat to level 5 (kill ~20 enemies or modify code temporarily)
3. Press special attack:
   - Player jumps up
   - Slams down with visual ring
   - Nearby enemies take damage + get stunned (blue tint)
   - Screen shakes
4. Try again immediately → on cooldown (3s)
5. Wait 3s → can use again
</verification>

<success_criteria>
- Ground pound locked until level 5
- AoE damages all nearby enemies
- Stun effect visible (blue tint, enemies stop moving)
- Cooldown prevents spam
- Visual/audio feedback feels impactful
</success_criteria>

<output>
After completion, create `.planning/phases/10-special-abilities/10-02-SUMMARY.md`
</output>
