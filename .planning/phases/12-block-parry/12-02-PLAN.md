---
phase: 12-block-parry
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - characters/player/states/player_block.gd
  - components/guard/guard_component.gd
  - ui/hud/guard_bar.gd
  - ui/hud/guard_bar.tscn
  - ui/hud/game_hud.gd
  - ui/hud/game_hud.tscn
  - autoloads/events.gd
  - autoloads/effects_manager.gd
autonomous: true

must_haves:
  truths:
    - "Perfect parry triggers in first 0.15s of block"
    - "Perfect parry stuns attacker for 1s"
    - "Perfect parry reflects 50% damage back"
    - "Guard meter visible in HUD"
    - "Parry has distinct visual/audio feedback"
  artifacts:
    - path: "ui/hud/guard_bar.gd"
      provides: "Guard meter UI"
    - path: "characters/player/states/player_block.gd"
      provides: "Parry timing logic"
      contains: "PARRY_WINDOW"
  key_links:
    - from: "player_block.gd"
      to: "events.gd"
      via: "player_parried signal"
      pattern: "player_parried\\.emit"
    - from: "guard_bar.gd"
      to: "events.gd"
      via: "guard_changed connection"
      pattern: "guard_changed\\.connect"
---

<objective>
Add parry mechanics and guard meter UI for skill-based defensive play.

Purpose: Reward precise timing with powerful counterattack, show guard status to player
Output: Working parry system with visual feedback and HUD guard bar
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-block-parry/12-01-SUMMARY.md
@characters/player/states/player_block.gd
@components/guard/guard_component.gd
@ui/hud/health_bar.gd
@ui/hud/game_hud.tscn
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parry mechanics to PlayerBlock</name>
  <files>
    characters/player/states/player_block.gd
    components/guard/guard_component.gd
    autoloads/events.gd
  </files>
  <action>
Update PlayerBlock state to track parry window:

```gdscript
extends State
class_name PlayerBlock

const PARRY_WINDOW: float = 0.15  # First 150ms = perfect parry

var block_timer: float = 0.0
var parry_available: bool = true

func enter() -> void:
    block_timer = 0.0
    parry_available = true
    
    if not player.guard or not player.guard.can_block():
        state_machine.transition_to("Idle")
        return
    
    player.guard.start_blocking()
    player.velocity = Vector2.ZERO
    
    # Visual: blocking stance
    if player.sprite:
        player.sprite.color = Color(0.7, 0.7, 0.8, 1.0)
    
    Events.player_block_started.emit()

func exit() -> void:
    if player.guard:
        player.guard.stop_blocking()
    if player.sprite:
        player.sprite.color = Color.WHITE
    Events.player_block_ended.emit()

func physics_update(delta: float) -> void:
    block_timer += delta
    
    # Parry window expires
    if parry_available and block_timer > PARRY_WINDOW:
        parry_available = false
    
    if not Input.is_action_pressed("block") or not player.guard.can_block():
        state_machine.transition_to("Idle")
        return
    
    player.velocity = Vector2.ZERO
    player.move_and_slide()

func is_in_parry_window() -> bool:
    return parry_available and block_timer <= PARRY_WINDOW
```

Add to GuardComponent - method to check parry and handle counter:

```gdscript
## Called when hit while blocking - returns true if parried
func on_blocked_hit(attacker: Node, incoming_damage: int) -> bool:
    var player_block = get_parent().state_machine.current_state
    if player_block and player_block.has_method("is_in_parry_window"):
        if player_block.is_in_parry_window():
            # Perfect parry!
            _execute_parry(attacker, incoming_damage)
            return true
    
    # Normal block - drain guard
    use_guard(15.0)
    return false

func _execute_parry(attacker: Node, incoming_damage: int) -> void:
    # Reflect 50% damage back
    var reflect_damage = int(incoming_damage * 0.5)
    if attacker.has_method("take_reflected_damage"):
        attacker.take_reflected_damage(reflect_damage)
    elif attacker.has_node("HealthComponent"):
        attacker.get_node("HealthComponent").take_damage(reflect_damage)
    
    # Stun attacker
    if attacker.has_method("apply_stun"):
        attacker.apply_stun(1.0)
    
    Events.player_parried.emit(attacker, reflect_damage)
```

Add to Events:
- `signal player_parried(attacker: Node, reflected_damage: int)`

Update player.gd `_on_hurt()` to use new parry check:
```gdscript
func _on_hurt(attacking_hitbox: Hitbox) -> void:
    var damage = attacking_hitbox.damage
    var attacker = attacking_hitbox.get_parent()
    
    # Check for parry/block
    if guard and guard.is_blocking:
        if guard.on_blocked_hit(attacker, damage):
            # Perfect parry - no damage taken
            return
        # Normal block - reduced damage
        damage = int(damage * (1.0 - guard.get_damage_reduction()))
    
    if health:
        health.take_damage(damage)
    if health and not health.is_dead():
        if not (guard and guard.is_blocking):
            state_machine.transition_to("Hurt")
```
  </action>
  <verify>
Block at exact moment of enemy attack - should parry (enemy takes damage, gets stunned)
Block slightly late - should normal block (reduced damage)
  </verify>
  <done>Parry window works, reflects damage, stuns attacker</done>
</task>

<task type="auto">
  <name>Task 2: Add stun support to enemies</name>
  <files>
    characters/enemies/enemy_base.gd
    characters/enemies/states/enemy_stunned.gd
  </files>
  <action>
Add stun handling to enemy_base.gd:

```gdscript
var stun_timer: float = 0.0
var is_stunned: bool = false

func apply_stun(duration: float) -> void:
    stun_timer = duration
    is_stunned = true
    if state_machine:
        state_machine.transition_to("Stunned")

func _process(delta: float) -> void:
    if is_stunned:
        stun_timer -= delta
        if stun_timer <= 0:
            is_stunned = false
            if state_machine:
                state_machine.transition_to("Idle")
```

Create enemy_stunned.gd state:

```gdscript
extends State
class_name EnemyStunned

func enter() -> void:
    enemy.velocity = Vector2.ZERO
    # Visual: flash yellow/white to show stunned
    if enemy.sprite:
        enemy.sprite.color = Color(1.0, 1.0, 0.5, 1.0)

func exit() -> void:
    if enemy.sprite:
        enemy.sprite.color = Color.WHITE

func physics_update(_delta: float) -> void:
    enemy.velocity = Vector2.ZERO
    enemy.move_and_slide()
    
    # Exit when stun ends (handled by enemy_base._process)
    if not enemy.is_stunned:
        state_machine.transition_to("Idle")
```

Add Stunned state to enemy state machines (raccoon.tscn, crow.tscn, boss_raccoon_king.tscn).
  </action>
  <verify>
Parry an enemy - they should turn yellow and stop moving for 1 second
After stun ends - enemy returns to normal behavior
  </verify>
  <done>Enemies have Stunned state, parry applies stun correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create guard bar UI</name>
  <files>
    ui/hud/guard_bar.gd
    ui/hud/guard_bar.tscn
    ui/hud/game_hud.gd
    ui/hud/game_hud.tscn
  </files>
  <action>
Create GuardBar following HealthBar pattern:

guard_bar.gd:
```gdscript
extends Control
class_name GuardBar

@onready var bar: ProgressBar = $ProgressBar
@onready var label: Label = $Label

func _ready() -> void:
    Events.guard_changed.connect(_on_guard_changed)
    # Hide initially until player blocks
    modulate.a = 0.3

func _on_guard_changed(current: float, max_guard: float) -> void:
    if bar:
        bar.max_value = max_guard
        bar.value = current
    if label:
        label.text = str(int(current))
    
    # Show bar when not full, fade when full
    modulate.a = 1.0 if current < max_guard else 0.3
```

guard_bar.tscn:
- Control node (root)
  - ProgressBar (blue/cyan color, 60x8 pixels)
  - Label (small, shows number)

Add guard_changed signal to Events (emitted by GuardComponent).

Update game_hud.tscn:
- Add GuardBar below HealthBar (offset down by ~12 pixels)

Update game_hud.gd to reference guard bar if needed.
  </action>
  <verify>
Guard bar visible below health bar
Guard bar depletes while blocking (turns more opaque)
Guard bar refills when not blocking (fades when full)
  </verify>
  <done>Guard bar shows in HUD, updates with guard meter state</done>
</task>

</tasks>

<verification>
1. Run game
2. Guard bar visible (faded) below health bar
3. Press C to block - guard bar becomes solid, starts depleting
4. Release C - guard bar regenerates after delay
5. Time block perfectly as enemy attacks - PARRY triggers:
   - Enemy turns yellow (stunned)
   - Enemy takes reflected damage
   - Player takes NO damage
6. Block slightly late - normal block (half damage, guard drains)
</verification>

<success_criteria>
- Parry window is 0.15 seconds at start of block
- Perfect parry reflects 50% damage to attacker
- Perfect parry stuns attacker for 1 second
- Enemies have functional Stunned state
- Guard bar displays in HUD
- Guard bar updates in real-time
- Distinct visual feedback for parry vs block
</success_criteria>

<output>
After completion, create `.planning/phases/12-block-parry/12-02-SUMMARY.md`
</output>
