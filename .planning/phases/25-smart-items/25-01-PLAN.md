---
phase: 25-smart-items
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autoloads/auto_bot.gd
autonomous: true

must_haves:
  truths:
    - "Bot uses acorn/bird_seed when HP is between 70-90% (light damage)"
    - "Bot uses health_potion when HP is between 40-70% (moderate damage)"
    - "Bot uses mega_potion/full_heal when HP is below 40% (heavy damage)"
    - "Bot uses guard_snack when guard meter is below 20% and enemies are nearby"
    - "Bot uses power_treat before engaging mini-boss or when 3+ enemies nearby"
    - "Bot uses speed_treat when critical health for retreat"
    - "Bot uses tough_treat before engaging mini-boss or when surrounded"
    - "Bot does not waste buff treats if buff is already active"
  artifacts:
    - path: "autoloads/auto_bot.gd"
      provides: "Smart healing, guard snack, and buff treat AI logic"
      contains: "_try_use_smart_healing, _try_use_guard_snack, _try_use_buff_treats"
  key_links:
    - from: "autoloads/auto_bot.gd"
      to: "GameManager.inventory"
      via: "has_item() and use_item() calls"
      pattern: "GameManager\\.inventory\\.(has_item|use_item)"
    - from: "autoloads/auto_bot.gd"
      to: "player_ref.guard"
      via: "get_guard_percent() for guard snack trigger"
      pattern: "player_ref\\.guard\\.get_guard_percent"
    - from: "autoloads/auto_bot.gd"
      to: "GameManager.inventory.active_buffs"
      via: "has_buff() to prevent duplicate buff usage"
      pattern: "GameManager\\.inventory\\.has_buff"
---

<objective>
Upgrade AutoBot's item usage from simple health-potion-only to smart situational usage of ALL consumable items: tiered healing (small items for light damage, potions for heavy), guard snack when guard breaks in combat, and buff treats before tough encounters.

Purpose: The bot currently wastes potions on minor scratches and ignores 5 item types entirely. This plan makes it use the full inventory intelligently.
Output: Modified auto_bot.gd with smart healing, guard snack, and buff treat logic.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@autoloads/auto_bot.gd
@systems/inventory/inventory.gd
@systems/inventory/item_database.gd
@components/guard/guard_component.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Smart Tiered Healing System</name>
  <files>autoloads/auto_bot.gd</files>
  <action>
Replace the existing `_try_use_healing_item()` function (lines 1140-1158) with a new `_try_use_smart_healing()` that picks items based on damage severity:

**New constants to add** (in CONFIGURATION section, after line 52):
```
const LIGHT_DAMAGE_THRESHOLD: float = 0.9   # Above 70% HP = light damage (use acorn/seed)
const MODERATE_DAMAGE_THRESHOLD: float = 0.5 # 40-70% HP = moderate (use health_potion)
const HEAVY_DAMAGE_THRESHOLD: float = 0.4    # Below 40% HP = heavy (use mega_potion/full_heal)
```

**New function `_try_use_smart_healing()`** — replaces `_try_use_healing_item()`:

Logic flow:
1. Check spam prevention (same 3.0s cooldown as current)
2. Check `GameManager.inventory` exists
3. Branch by HP percent:
   - `player_health_percent < HEAVY_DAMAGE_THRESHOLD` (critical/heavy): Try `full_heal` → `mega_potion` → `health_potion` (use strongest available)
   - `player_health_percent < MODERATE_DAMAGE_THRESHOLD` (moderate): Try `health_potion` → `mega_potion` (don't waste full_heal on moderate)
   - `player_health_percent < LIGHT_DAMAGE_THRESHOLD` (light): Try `acorn` → `bird_seed` (save potions for real damage)
4. For each tier, iterate items_to_try array, call `GameManager.inventory.has_item()` then `GameManager.inventory.use_item()`, print log, set `last_item_use_time`

**Update the call site** in `_update_phase16_systems()` (line 1125-1126):
- Change the condition from `if is_low_health and nearby_enemy_count == 0:` to:
  `if player_health_percent < LIGHT_DAMAGE_THRESHOLD and nearby_enemy_count == 0:`
- This allows healing at higher HP thresholds when safe (not just below 40%)
- Change `_try_use_healing_item()` → `_try_use_smart_healing()`

**Also add combat healing**: In `_update_phase16_systems()`, REMOVE the early return on line 1121-1122 (`if nearby_enemy_count > 0 and nearest_enemy_dist < 100: return`). Instead, allow critical health healing even in combat:
```gdscript
# Allow critical healing even in combat
if is_critical_health:
    _try_use_smart_healing()
```
Place this BEFORE the existing early return check for combat proximity.
  </action>
  <verify>
Search auto_bot.gd for `_try_use_smart_healing` — function must exist with tiered item arrays.
Search auto_bot.gd for `LIGHT_DAMAGE_THRESHOLD` — constant must exist.
Verify `_try_use_healing_item` is fully replaced (no remaining calls).
Verify the function tries acorn/bird_seed for light damage tier.
  </verify>
  <done>
Bot has 3-tier healing: light (acorn/bird_seed at 70-90% HP), moderate (health_potion at 40-70% HP), heavy (full_heal/mega_potion below 40% HP). Critical health triggers healing even in combat.
  </done>
</task>

<task type="auto">
  <name>Task 2: Guard Snack Usage When Guard Breaks</name>
  <files>autoloads/auto_bot.gd</files>
  <action>
Add guard snack logic that uses `guard_snack` when guard meter is low during combat.

**New constant** (in CONFIGURATION section):
```
const GUARD_SNACK_THRESHOLD: float = 0.2  # Use guard snack below 20% guard
```

**New state variable** (in STATE section):
```
var last_guard_snack_time: float = 0.0  # Prevent guard snack spam
```

**New function `_try_use_guard_snack()`**:
1. Spam prevention: `current_time - last_guard_snack_time < 5.0` → return
2. Check `GameManager.inventory` exists
3. Check `player_ref.guard` exists (guard component reference — already used at line 751)
4. Check guard percent: `player_ref.guard.get_guard_percent() < GUARD_SNACK_THRESHOLD`
5. Check if in combat: `nearby_enemy_count > 0`
6. Try to use: `GameManager.inventory.has_item("guard_snack")` → `GameManager.inventory.use_item("guard_snack")`
7. Print `[AutoBot] Used guard_snack (guard was %.0f%%)` with guard percent
8. Set `last_guard_snack_time = current_time`

**Call site in `_update_phase16_systems()`**: Add after the critical healing check, inside the `nearby_enemy_count > 0` block (since guard snacks only matter in combat):
```gdscript
# Use guard snack when guard is low in combat
if nearby_enemy_count > 0:
    _try_use_guard_snack()
```
  </action>
  <verify>
Search auto_bot.gd for `_try_use_guard_snack` — function must exist.
Search for `guard_snack` — must appear in the new function.
Search for `GUARD_SNACK_THRESHOLD` — constant must exist with value 0.2.
  </verify>
  <done>
Bot uses guard_snack when guard meter drops below 20% during combat. Has 5s cooldown to prevent spam.
  </done>
</task>

<task type="auto">
  <name>Task 3: Buff Treat Usage Before Tough Fights</name>
  <files>autoloads/auto_bot.gd</files>
  <action>
Add buff treat logic that uses power/speed/tough treats situationally before tough encounters.

**New constants** (in CONFIGURATION section):
```
const BUFF_ENEMY_THRESHOLD: int = 3       # Use buffs when 3+ enemies nearby
const BUFF_COOLDOWN: float = 35.0          # Don't re-buff within 35s (buff lasts 30s + 5s grace)
```

**New state variables** (in STATE section):
```
var last_buff_use_time: float = 0.0  # Prevent buff spam
```

**New function `_try_use_buff_treats()`**:
1. Spam prevention: `current_time - last_buff_use_time < BUFF_COOLDOWN` → return
2. Check `GameManager.inventory` exists
3. Determine if situation warrants buffs:
   - `is_tough_fight`: `nearby_enemy_count >= BUFF_ENEMY_THRESHOLD` OR target_enemy has a "MiniBoss" ancestor (check with `target_enemy.is_in_group("mini_bosses")` if that group exists, otherwise check `target_enemy.get_class()` or check if the enemy has > 80 HP via HealthComponent)
   - If NOT tough fight → return
4. Try each buff IF not already active (check `GameManager.inventory.has_buff()`):
   - `power_treat`: Use if `not GameManager.inventory.has_buff(ItemDatabase.EffectType.BUFF_ATTACK)` — boosts damage for tough fights
   - `tough_treat`: Use if `not GameManager.inventory.has_buff(ItemDatabase.EffectType.BUFF_DEFENSE)` — reduce incoming damage
   - `speed_treat`: Use if `is_critical_health and not GameManager.inventory.has_buff(ItemDatabase.EffectType.BUFF_SPEED)` — speed helps escape
5. For each buff used: `GameManager.inventory.has_item(id)` → `GameManager.inventory.use_item(id)`, print log, set `last_buff_use_time = current_time`, return after first successful use (one buff per cycle to avoid using all at once)

**Tough enemy detection helper `_is_tough_enemy(enemy: Node) -> bool`**:
```gdscript
func _is_tough_enemy(enemy: Node) -> bool:
    if enemy == null or not is_instance_valid(enemy):
        return false
    # Check if mini-boss (high HP enemies)
    if enemy.has_node("HealthComponent"):
        var health = enemy.get_node("HealthComponent")
        if health.max_health >= 80:
            return true
    return false
```

**Call site in `_update_phase16_systems()`**: Add near the combat section:
```gdscript
# Use buff treats before tough encounters
if nearby_enemy_count > 0 and target_enemy != null:
    _try_use_buff_treats()
```
This should be placed AFTER the guard snack check, still within the combat block.

Also add speed_treat usage when retreating at critical health — in the buff function, always consider speed_treat when `is_critical_health` regardless of tough fight status.
  </action>
  <verify>
Search auto_bot.gd for `_try_use_buff_treats` — function must exist.
Search for `power_treat` — must appear in buff logic.
Search for `_is_tough_enemy` — helper function must exist.
Search for `has_buff` — must check active buffs before using treats.
Verify `BUFF_ENEMY_THRESHOLD` and `BUFF_COOLDOWN` constants exist.
  </verify>
  <done>
Bot uses power_treat and tough_treat before mini-boss or 3+ enemy fights. Uses speed_treat at critical HP for escape. Never wastes treats when buff already active. One buff per decision cycle to spread usage.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `grep -n "_try_use_smart_healing\|_try_use_guard_snack\|_try_use_buff_treats\|_is_tough_enemy" autoloads/auto_bot.gd` — all 4 functions exist
2. `grep -n "LIGHT_DAMAGE_THRESHOLD\|GUARD_SNACK_THRESHOLD\|BUFF_ENEMY_THRESHOLD\|BUFF_COOLDOWN" autoloads/auto_bot.gd` — all 4 constants exist
3. `grep -c "_try_use_healing_item" autoloads/auto_bot.gd` — returns 0 (old function fully removed)
4. `grep -n "acorn\|bird_seed\|guard_snack\|power_treat\|speed_treat\|tough_treat" autoloads/auto_bot.gd` — all 6 previously-unused items now referenced
5. `grep -n "has_buff" autoloads/auto_bot.gd` — buff duplication prevention exists
6. Godot project opens without parse errors
</verification>

<success_criteria>
- Smart 3-tier healing replaces old flat healing (acorn/seed for light, potion for moderate, mega/full for heavy)
- Guard snack used when guard < 20% in combat
- Buff treats used before tough fights (mini-boss or 3+ enemies)
- Speed treat used at critical health for escape
- No buff duplication (checks has_buff before using)
- All 6 previously-unused item types now have bot usage logic
- No references to old `_try_use_healing_item` remain
</success_criteria>

<output>
After completion, create `.planning/phases/25-smart-items/25-01-SUMMARY.md`
</output>
